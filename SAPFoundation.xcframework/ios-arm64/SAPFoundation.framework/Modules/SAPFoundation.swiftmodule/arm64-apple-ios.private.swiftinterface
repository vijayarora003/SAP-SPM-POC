// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target arm64-apple-ios16.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SAPFoundation
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AuthenticationServices
import SystemConfiguration.CaptiveNetwork
import Combine
import CoreTelephony
import CryptoKit
import Darwin
import DeviceCheck
import Dispatch
import Foundation
import MachO
import ObjectiveC
import SAPCommon
@_exported import SAPFoundation
import SafariServices
import Swift
import SystemConfiguration
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
open class JSONConfigurationProvider : SAPFoundation.ConfigurationProviding {
  public init()
  public var providerIdentifier: Swift.String {
    get
  }
  public var expectedInput: [Swift.String : Any] {
    get
  }
  public func provideConfiguration(input: [Swift.String : Any] = [:]) -> (providerSuccess: Swift.Bool, configuration: Foundation.NSDictionary, returnError: (any Swift.Error)?)
  @objc deinit
}
public enum IdentityError : Swift.Error {
  case failedToCreateIdentity
  case failedToCreatePkcs12Data
  case failedToExportCertificateData
  case failedToExportPrivateKey
  public static func == (a: SAPFoundation.IdentityError, b: SAPFoundation.IdentityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.IdentityError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class OAuth2Authenticator : SAPFoundation.OAuth2Authentication {
  public static func defaultSAPURLSession() -> SAPFoundation.SAPURLSession
  public func authenticate(completionHandler: @escaping (_ token: SAPFoundation.OAuth2Token?, _ error: (any Swift.Error)?) -> Swift.Void)
  public func refresh(token: SAPFoundation.OAuth2Token, completionHandler: @escaping (_ newToken: SAPFoundation.OAuth2Token?, _ error: (any Swift.Error)?) -> Swift.Void)
  public func cancelAuthentication()
  @objc deinit
}
public protocol AuthenticationHandling : AnyObject {
  func authenticationObserver(_ observer: any SAPFoundation.SAPURLSessionObserving, didAuthenticate session: SAPFoundation.SAPURLSession, requestBypassIdentifier: Foundation.UUID, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  func authenticationObserver(_ observer: any SAPFoundation.SAPURLSessionObserving, didFailToAuthenticate session: SAPFoundation.SAPURLSession, error: any Swift.Error)
}
public struct APIKeyCredential : Swift.Codable {
  public func keys() -> [Swift.String]
  public init(apikeys: [Swift.String])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol SceneDelegateObserving : SAPFoundation.EventObserving {
  func scene(_ scene: UIKit.UIScene, openURLContexts URLContexts: Swift.Set<UIKit.UIOpenURLContext>)
  func scene(_ scene: UIKit.UIScene, willConnectTo session: UIKit.UISceneSession, options connectionOptions: UIKit.UIScene.ConnectionOptions)
  func scene(_ scene: UIKit.UIScene, continue userActivity: Foundation.NSUserActivity)
  func onboardingSceneDidChange(_ scene: UIKit.UIScene, newOnboardingScene sessionID: Swift.String)
  func sceneWillEnterForeground(_ scene: UIKit.UIScene)
  func sceneDidEnterBackground(_ scene: UIKit.UIScene)
}
extension SAPFoundation.SceneDelegateObserving {
  public func scene(_ scene: UIKit.UIScene, openURLContexts URLContexts: Swift.Set<UIKit.UIOpenURLContext>)
  public func scene(_ scene: UIKit.UIScene, willConnectTo session: UIKit.UISceneSession, options connectionOptions: UIKit.UIScene.ConnectionOptions)
  public func scene(_ scene: UIKit.UIScene, continue userActivity: Foundation.NSUserActivity)
  public func onboardingSceneDidChange(_ scene: UIKit.UIScene, newOnboardingScene sessionID: Swift.String)
  public func sceneWillEnterForeground(_ scene: UIKit.UIScene)
  public func sceneDidEnterBackground(_ scene: UIKit.UIScene)
}
public struct ResourceInfo {
  public let resourceName: Swift.String
  public let resourceVersion: Swift.String
  public let resourceExtension: Swift.String
  public let isDefault: Swift.Bool
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SAPURLSessionDownloadTask : SAPFoundation.SAPURLSessionTask {
  public func cancel(byProducingResumeData completionHandler: @escaping (Foundation.Data?) -> Swift.Void)
  @objc deinit
}
open class UserIdentityObserver {
  public var authenticationHandler: (any SAPFoundation.AuthenticationHandling)?
  public init(userIdentityDiscovery: any SAPFoundation.UserIdentityObtaining, identityStore: any SAPFoundation.UserIdentityStoring)
  @objc deinit
}
extension SAPFoundation.UserIdentityObserver : SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (SAPFoundation.SAPURLSession.AuthChallengeDisposition) -> Swift.Void)
  public func copy() -> Any?
}
public enum SAPcpmsUserBlockedError : Swift.Error {
  case traffic
  case trafficAndRegistration
  case registration
  public static func == (a: SAPFoundation.SAPcpmsUserBlockedError, b: SAPFoundation.SAPcpmsUserBlockedError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class SAPcpmsUserBlockedObserver : SAPFoundation.SAPURLSessionObserving {
  final public let blockedHTTPStatusCode: Swift.Int
  final public let blockedHTTPHeaderName: Swift.String
  final public let userBlockedHandler: (SAPFoundation.SAPcpmsUserBlockedError) -> Swift.Void
  public init(userBlockedHandler: @escaping (SAPFoundation.SAPcpmsUserBlockedError) -> Swift.Void)
  open func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  open func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  open func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func copy() -> Any?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension SAPFoundation.UserIdentityObserver {
  convenience public init(userIdentityConfigurationParameters: SAPFoundation.SAPcpmsUserIdentityConfigurationParameters, oAuth2AuthenticationParameters: SAPFoundation.OAuth2AuthenticationParameters, identityStore: any SAPFoundation.UserIdentityStoring, applicationID: Swift.String? = nil)
  convenience public init?(certificateDiscoveryConfiguration configuration: [Swift.String : Any], identityStore: any SAPFoundation.UserIdentityStoring, applicationID: Swift.String? = nil)
}
public enum AuthenticationObserverError : Swift.Error {
  case retryCountReached
  public static func == (a: SAPFoundation.AuthenticationObserverError, b: SAPFoundation.AuthenticationObserverError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.AuthenticationObserverError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
open class SAPcpmsUserRoles {
  public struct SAPcpmsUserInfo {
    public let id: Swift.String
    public let userName: Swift.String
    public let roles: [Swift.String]?
    public let detail: Swift.String?
    public let familyName: Swift.String?
    public let givenName: Swift.String?
    public let emails: [[Swift.String : Any]]?
    public let others: [Swift.String : Any]?
    public init(id: Swift.String, userName: Swift.String, roles: [Swift.String]? = nil, detail: Swift.String? = nil, familyName: Swift.String? = nil, givenName: Swift.String? = nil, emails: [[Swift.String : Any]]? = nil, others: [Swift.String : Any]? = nil)
  }
  public init(sapURLSession: SAPFoundation.SAPURLSession, roleServiceUrl: Foundation.URL)
  convenience public init(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  open func load(completionHandler: @escaping (SAPFoundation.SAPcpmsUserRoles.SAPcpmsUserInfo?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
open class SecureStoreCache<Value> : SAPFoundation.Caching where Value : Foundation.NSCoding {
  public typealias KeyType = Swift.String
  public typealias ValueType = Value
  public typealias SecureStoreCacheEntry = SAPFoundation.CacheEntry<Value>
  final public let maximumNumberOfEntries: Swift.Int
  final public let maximumCost: Swift.Double
  public var store: SAPFoundation.SecureDatabaseStore? {
    get
  }
  required public init(maximumNumberOfEntries: Swift.Int = 0, maximumCost: Swift.Double = 0, secureStore: SAPFoundation.SecureDatabaseStore, tableName: Swift.String = "SApcpSDKSecureStoreCache")
  open var costOfEntries: Swift.Double {
    get
  }
  open var numberOfEntries: Swift.Int {
    get
  }
  open func set(value: SAPFoundation.SecureStoreCache<Value>.ValueType, forKey key: SAPFoundation.SecureStoreCache<Value>.KeyType, withCost cost: Swift.Double = 0)
  open func value(forKey key: SAPFoundation.SecureStoreCache<Value>.KeyType) -> SAPFoundation.SecureStoreCache<Value>.ValueType?
  open func entry(forKey key: SAPFoundation.SecureStoreCache<Value>.KeyType) -> SAPFoundation.CacheEntry<SAPFoundation.SecureStoreCache<Value>.ValueType>?
  open func removeValue(forKey key: SAPFoundation.SecureStoreCache<Value>.KeyType)
  open func removeAllValues()
  open func keys() -> Swift.AnySequence<SAPFoundation.SecureStoreCache<Value>.KeyType>
  @objc deinit
}
public enum ClipboardProtectionError : Swift.Error {
  case failedToEnforceBlocking
  public static func == (a: SAPFoundation.ClipboardProtectionError, b: SAPFoundation.ClipboardProtectionError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.ClipboardProtectionError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public let DiscoveryServiceHost: Swift.String
public let DiscoveryServicePort: Swift.String
public let DiscoveryServiceProtocol: Swift.String
public let DiscoveryServiceAuth: Swift.String
public let DiscoveryServiceType: Swift.String
public let DiscoveryServiceConfig: Swift.String
public let DiscoveryServiceAppID: Swift.String
public class AuxiliaryDataRequestManager {
  public typealias CommunicationProvider = SAPFoundation.AuxiliaryCommunicationProvider
  convenience public init(dataStore: any SAPCommon.DataStoring) throws
  public init(provider: SAPFoundation.AuxiliaryDataRequestManager.CommunicationProvider)
  public func putDataRequest<T>(dataRequest: SAPFoundation.AuxiliaryDataRequest<T>) throws where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Hashable
  public func getDataRequest<T>() throws -> SAPFoundation.AuxiliaryDataRequest<T>? where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Hashable
  public func completeDataRequest<T>(dataRequest: SAPFoundation.AuxiliaryDataRequest<T>) throws where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Hashable
  @objc deinit
}
public protocol APIKeyCredentialDiscovery : AnyObject {
  func provideAPIKeyCredential(for appplicationId: Swift.String?, user: Swift.String?) -> SAPFoundation.APIKeyCredential?
}
@_hasMissingDesignatedInitializers public class SecureDatabaseStore {
  final public let databaseURL: Foundation.URL
  convenience public init(databaseFileName: Swift.String = "SAPcpSDKDefaultSecureDatabaseStore.db")
  convenience public init(fullDatabasePath: Swift.String)
  public func open(with encryptionKey: Swift.String, initializationHandler: ((SAPFoundation.SecureDatabaseStore) -> (any Swift.Error)?) = SecureDatabaseStore.defaultInitializationHandler) throws
  public func open(with encryptionKeyData: Foundation.Data, initializationHandler: (SAPFoundation.SecureDatabaseStore) -> (any Swift.Error)? = SecureDatabaseStore.defaultInitializationHandler) throws
  public func isOpen() -> Swift.Bool
  public func close()
  public func changeEncryptionKey(with newEncryptionKey: Swift.String) throws
  public func changeEncryptionKey(with newEncryptionKeyData: Foundation.Data) throws
  public func executeUpdate(_ sql: Swift.String) throws
  public func executeUpdate(_ sql: Swift.String, values: [(any SAPFoundation.SQLiteDatatypeBridgeable)?]) throws
  public func executeUpdate(_ sql: Swift.String, parameterDictionary: [Swift.String : (any SAPFoundation.SQLiteDatatypeBridgeable)?]) throws
  public func executeStatements(_ sql: Swift.String) throws
  public func executeStatements(_ sql: Swift.String, resultBlock: @escaping (_ results: [Swift.String : Swift.String?]) -> Swift.Bool) throws
  public func lastInsertRowId() throws -> Swift.Int64
  public func changedRowCount() throws -> Swift.Int
  public func executeQuery(_ sql: Swift.String) throws -> SAPFoundation.SecureDatabaseResultSet
  public func executeQuery(_ sql: Swift.String, values: [(any SAPFoundation.SQLiteDatatypeBridgeable)?]) throws -> SAPFoundation.SecureDatabaseResultSet
  public func executeQuery(_ sql: Swift.String, parameterDictionary: [Swift.String : (any SAPFoundation.SQLiteDatatypeBridgeable)?]) throws -> SAPFoundation.SecureDatabaseResultSet
  public func beginExclusiveTransaction() throws
  public func beginDeferredTransaction() throws
  public func commit() throws
  public func rollback() throws
  public func isInTransaction() throws -> Swift.Bool
  public var shouldCacheStatements: Swift.Bool {
    get
    set(shouldCache)
  }
  public func clearCachedStatements()
  public var hasOpenResultSets: Swift.Bool {
    get
  }
  public func closeOpenResultSets()
  public static func defaultInitializationHandler(_ store: SAPFoundation.SecureDatabaseStore) -> (any Swift.Error)?
  @objc deinit
}
public struct SAPcpmsSharedDeviceSettings {
  public let allowUploadPendingChangesFromPreviousUser: Swift.Bool
  public init(allowUploadPendingChangesFromPreviousUser: Swift.Bool = false)
}
extension SAPFoundation.SAPcpmsSharedDeviceSettings {
  public init?(sapcpmsSettings: Any) throws
  public init?(sharedDeviceSettings: Any) throws
}
@_hasMissingDesignatedInitializers public class SAPcpmsDeviceSecurityAuditUploader {
  #if compiler(>=5.3) && $AsyncAwait
  public static func upload(isDeviceCompromised: Swift.Bool, sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters) async throws
  #endif
  @objc deinit
}
public struct SLSLoginInputFieldValue {
  public let fieldName: Swift.String
  public let value: Swift.String
  public init(fieldName: Swift.String, value: Swift.String)
}
public protocol CoderProtocol {
  func encode<Value>(_ value: Value) throws -> Foundation.Data where Value : Swift.Encodable
  func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
}
public enum SAPcpmsAuthenticationManagerError : Swift.Error {
  case userSwitch(from: Swift.String, to: Swift.String)
}
extension SAPFoundation.SAPcpmsAuthenticationManagerError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public enum DeviceComplianceDetectionPolicy : Swift.String {
  case ignore
  case report
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SAPcpmsFeatureVectorPolicy {
  public let featureVectorPolicyAllEnabled: Swift.Bool
  public let restrictedPolicies: [SAPFoundation.SAPcpmsFeature]
  public let allowedPolicies: [SAPFoundation.SAPcpmsFeature]
}
extension SAPFoundation.SAPcpmsFeatureVectorPolicy {
  public init?(sapcpmsSettings: Any) throws
  public init?(sapcpmsFeatureVectorePolicy: Any) throws
}
extension SAPFoundation.SAPcpmsFeatureVectorPolicy : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
open class SAPPassportObserver : SAPFoundation.SAPURLSessionObserving {
  public init(passportManager: any SAPFoundation.SAPPassportManaging = MeteringPassportManager())
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  @objc deinit
}
public let BasicAuthenticationParametersDiscoveryServiceAuthType: Swift.String
public let NoneAuthenticationParametersDiscoveryServiceAuthType: Swift.String
public struct BasicCredential : Swift.Codable {
  public let username: Swift.String
  public let password: Swift.String
  public init(username: Swift.String, password: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class UserEventDispatcher : SAPFoundation.EventDispatching {
  public static var shared: SAPFoundation.UserEventDispatcher
  public var registeredObservers: [any SAPFoundation.UserEventObserving] {
    get
  }
  public func registerObserver(_ observer: any SAPFoundation.EventObserving)
  public func unregisterObserver(_ observer: any SAPFoundation.EventObserving)
  public func userAdded(with onboardingID: Foundation.UUID)
  public func userSwitched(to onboardingID: Foundation.UUID)
  @objc deinit
}
open class BasicAuthenticationObserver {
  public var authenticationHandler: (any SAPFoundation.AuthenticationHandling)?
  public var persistence: Foundation.URLCredential.Persistence
  public init(basicCredentialDiscovery: any SAPFoundation.BasicCredentialDiscovery = DefaultBasicCredentialDiscovery(), basicCredentialStore: any SAPFoundation.BasicCredentialStoring, retryCount: Swift.Int = 3)
  @objc deinit
}
extension SAPFoundation.BasicAuthenticationObserver : SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.HTTPRedirectDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (SAPFoundation.SAPURLSession.AuthChallengeDisposition) -> Swift.Void)
  public func copy() -> Any?
}
public enum PrintPolicyEnforcerError : Swift.Error {
  case failedToBlockUIPrintInteractionController
  case failedToBlockUIPrinterPickerController
  public static func == (a: SAPFoundation.PrintPolicyEnforcerError, b: SAPFoundation.PrintPolicyEnforcerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.PrintPolicyEnforcerError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers open class UsageBroker {
  public static let shared: SAPFoundation.UsageBroker
  public var store: SAPFoundation.UsageStore? {
    get
  }
  public var injectOSlifecycleSession: Swift.Bool {
    get
  }
  public var collectionItems: SAPFoundation.UsageDataCollectionItems {
    get
  }
  public var sapURLSession: SAPFoundation.SAPURLSession?
  public var onboardingID: Swift.String?
  public var enableServerOverride: Swift.Bool
  public var uploadInterval: Swift.Int
  public var sapcpmsSettingsParameters: SAPFoundation.SAPcpmsSettingsParameters {
    get
    set
  }
  public var enableReporting: Swift.Bool {
    get
    set
  }
  public func start(OSlifecycleSessionInjection enabled: Swift.Bool = true, DataCollection items: SAPFoundation.UsageDataCollectionItems = UsageDataCollectionItems.all, retainLastUnattributedSession: Swift.Bool = true) throws
  public func configure(path: Foundation.URL = UsageStore.defaultFolderURL, storageID: Foundation.UUID? = nil, encryptionKey: Swift.String? = nil, retainLastUnattributedSession: Swift.Bool = true) throws
  public func upload(overrideInterval force: Swift.Bool = false, sapcpmsSettingsParameters: SAPFoundation.SAPcpmsSettingsParameters? = nil, sendUnattributed unattributed: Swift.Bool = true, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void = SAPcpmsUsageUploader.defaultCompletionHandler)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SAPcpmsUsageUploader {
  public enum UploadError : SAPCommon.SAPError {
    case fileSystem(any Swift.Error)
    case network(any Swift.Error)
    case invalidResponse(Foundation.Data?, Foundation.URLResponse?)
    case emptyStore
    public var description: Swift.String {
      get
    }
    public var errorDescription: Swift.String? {
      get
    }
    public var debugDescription: Swift.String {
      get
    }
  }
  public static func upload(to settings: SAPFoundation.SAPcpmsSettingsParameters, sapURLSession: SAPFoundation.SAPURLSession, target: Swift.String = Usage.defaultTargetID, unattributedData: (any SAPCommon.UsageSnapshotting)? = nil, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void = SAPcpmsUsageUploader.defaultCompletionHandler)
  public static func upload(to uploadEndPoint: Foundation.URL, sapURLSession: SAPFoundation.SAPURLSession, target: Swift.String = Usage.defaultTargetID, sapcpmsSettingsParameters: SAPFoundation.SAPcpmsSettingsParameters? = nil, unattributedData: (any SAPCommon.UsageSnapshotting)? = nil, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void = SAPcpmsUsageUploader.defaultCompletionHandler)
  public static func defaultCompletionHandler(_ error: (any Swift.Error)?)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class SecureKeyValueStore : SAPFoundation.KeyValueStoreProtocol {
  final public let secureDatabaseStore: SAPFoundation.SecureDatabaseStore
  public static let defaultDatabaseFileName: Swift.String
  open var storeName: Swift.String
  convenience public init(databaseFileName: Swift.String = defaultDatabaseFileName, name: Swift.String = SecureStoreDefaultStoreName)
  convenience public init(fullDatabasePath: Swift.String, name: Swift.String = SecureStoreDefaultStoreName)
  convenience public init(databaseStore: SAPFoundation.SecureDatabaseStore, name: Swift.String = SecureStoreDefaultStoreName) throws
  @objc deinit
  open func open(with encryptionKey: Swift.String) throws
  open func open(with encryptionKeyData: Foundation.Data) throws
  open func isOpen() -> Swift.Bool
  open func close()
  open func changeEncryptionKey(with newEncryptionKey: Swift.String) throws
  open func changeEncryptionKey(with newEncryptionKeyData: Foundation.Data) throws
  open func put<T>(_ value: T?, forKey key: Swift.String) throws where T : SAPFoundation.SQLiteDatatypeBridgeable
  open func put<T>(_ value: T?, forKey key: Swift.String) throws where T : Foundation.NSCoding
  open func putAll(_ keyValueDict: [Swift.String : (any Foundation.NSCoding)?]) throws
  open func get<T>(_ key: Swift.String) throws -> T? where T : SAPFoundation.SQLiteDatatypeBridgeable
  open func get<T>(_ key: Swift.String) throws -> T? where T : Foundation.NSCoding
  open func getString(_ key: Swift.String) throws -> Swift.String?
  open func getInt8(_ key: Swift.String) throws -> Swift.Int8?
  open func getInt16(_ key: Swift.String) throws -> Swift.Int16?
  open func getInt32(_ key: Swift.String) throws -> Swift.Int32?
  open func getInt64(_ key: Swift.String) throws -> Swift.Int64?
  open func getInt(_ key: Swift.String) throws -> Swift.Int?
  open func getUInt8(_ key: Swift.String) throws -> Swift.UInt8?
  open func getUInt16(_ key: Swift.String) throws -> Swift.UInt16?
  open func getUInt32(_ key: Swift.String) throws -> Swift.UInt32?
  open func getUInt64(_ key: Swift.String) throws -> Swift.UInt64?
  open func getUInt(_ key: Swift.String) throws -> Swift.UInt?
  open func getFloat(_ key: Swift.String) throws -> Swift.Float?
  open func getDouble(_ key: Swift.String) throws -> Swift.Double?
  open func getBool(_ key: Swift.String) throws -> Swift.Bool?
  open func getData(_ key: Swift.String) throws -> Foundation.Data?
  open func get<T>(_ key: Swift.String, defaultValue: T?) throws -> T? where T : Foundation.NSCoding
  open func get<T>(_ key: Swift.String, defaultValue: T?) throws -> T? where T : SAPFoundation.SQLiteDatatypeBridgeable
  open func keys() throws -> Swift.Set<Swift.String>
  open func hasKey(_ key: Swift.String) throws -> Swift.Bool
  open func count() throws -> Swift.Int
  open func isEmpty() throws -> Swift.Bool
  @discardableResult
  open func remove(_ key: Swift.String) throws -> Swift.Bool
  open func removeAll() throws
}
public protocol KeyValueStoreProtocol {
  func put<T>(_ value: T?, forKey key: Swift.String) throws where T : SAPFoundation.SQLiteDatatypeBridgeable
  func put<T>(_ value: T?, forKey key: Swift.String) throws where T : Foundation.NSCoding
  func putAll(_ keyValueDict: [Swift.String : (any Foundation.NSCoding)?]) throws
  func get<T>(_ key: Swift.String) throws -> T? where T : Foundation.NSCoding
  func get<T>(_ key: Swift.String) throws -> T? where T : SAPFoundation.SQLiteDatatypeBridgeable
  func getString(_ key: Swift.String) throws -> Swift.String?
  func getInt8(_ key: Swift.String) throws -> Swift.Int8?
  func getInt16(_ key: Swift.String) throws -> Swift.Int16?
  func getInt32(_ key: Swift.String) throws -> Swift.Int32?
  func getInt64(_ key: Swift.String) throws -> Swift.Int64?
  func getInt(_ key: Swift.String) throws -> Swift.Int?
  func getUInt8(_ key: Swift.String) throws -> Swift.UInt8?
  func getUInt16(_ key: Swift.String) throws -> Swift.UInt16?
  func getUInt32(_ key: Swift.String) throws -> Swift.UInt32?
  func getUInt64(_ key: Swift.String) throws -> Swift.UInt64?
  func getUInt(_ key: Swift.String) throws -> Swift.UInt?
  func getFloat(_ key: Swift.String) throws -> Swift.Float?
  func getDouble(_ key: Swift.String) throws -> Swift.Double?
  func getBool(_ key: Swift.String) throws -> Swift.Bool?
  func getData(_ key: Swift.String) throws -> Foundation.Data?
  func get<T>(_ key: Swift.String, defaultValue: T?) throws -> T? where T : SAPFoundation.SQLiteDatatypeBridgeable
  func get<T>(_ key: Swift.String, defaultValue: T?) throws -> T? where T : Foundation.NSCoding
  func keys() throws -> Swift.Set<Swift.String>
  func hasKey(_ key: Swift.String) throws -> Swift.Bool
  func count() throws -> Swift.Int
  func isEmpty() throws -> Swift.Bool
  @discardableResult
  func remove(_ key: Swift.String) throws -> Swift.Bool
  func removeAll() throws
}
extension SAPFoundation.OAuth2Authenticator {
  convenience public init(authenticationParameters: SAPFoundation.OAuth2AuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession())
  convenience public init(authenticationParameters: SAPFoundation.OAuth2AuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession(), webViewPresenter: any SAPFoundation.WKWebViewPresenting)
  convenience public init(authenticationParameters: SAPFoundation.OAuth2AuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession(), webViewPresenter: any SAPFoundation.SFSafariViewControllerPresenting)
  @available(iOS 12.0, *)
  convenience public init(authenticationParameters: SAPFoundation.OAuth2AuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession(), webViewPresenter: any SAPFoundation.ASWebAuthenticationSessionPresenting)
}
public struct APIKeyAuthenticationConfig {
  public var apikeys: [Swift.String] {
    get
  }
  public var isAPIKeyAccessOnly: Swift.Bool {
    get
  }
  public init(apikeys: [Swift.String], isAPIKeyAccessOnly: Swift.Bool = false, allowAnonymousAccessFlag: Swift.Bool = false)
}
public enum SAPcpmsUserIdentityDiscoveryError : Swift.Error {
  case getCertificateAttributes
  case parseCertificateAttributes
  case createCSR
  case getCertificate(statusCode: Swift.Int)
  case parseCertificate
  case invalidUserIdentity
  case cancelled
}
extension SAPFoundation.SAPcpmsUserIdentityDiscoveryError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public class SAPcpmsObserver : SAPFoundation.SAPURLSessionObserving {
  final public let applicationID: Swift.String
  final public let deviceID: Swift.String?
  final public let applicationVersion: Swift.String?
  public init(applicationID: Swift.String, deviceID: Swift.String? = SAPcpmsSettingsParameters.defaultDeviceID, applicationVersion: Swift.String? = nil)
  convenience public init(settingsParameters parameters: SAPFoundation.SAPcpmsSettingsParameters)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func copy() -> Any?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PrintPolicyEnforcer {
  public static var shared: SAPFoundation.PrintPolicyEnforcer {
    get
  }
  public func enforce(policy: SAPFoundation.PrintPolicy = .blocked) throws
  public func getPrintPolicy() -> SAPFoundation.PrintPolicy
  @objc deinit
}
public protocol AuxiliaryDataRequestRepresenting {
  associatedtype AuxDataRequestType : Swift.Decodable, Swift.Encodable
  var creationTime: Foundation.Date { get set }
  var completionTime: Foundation.Date? { get set }
  var eSPAKAuxiliary: Foundation.Data { get set }
  func get() -> Self.AuxDataRequestType
}
open class PlistCoder : SAPFoundation.CoderProtocol {
  final public let encoder: Foundation.PropertyListEncoder
  final public let decoder: Foundation.PropertyListDecoder
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  open func encode<Value>(_ value: Value) throws -> Foundation.Data where Value : Swift.Encodable
  @objc deinit
}
public enum PrintPolicy : Swift.String {
  case blocked
  case unrestricted
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension SAPFoundation.UserIdentityObserver {
  convenience public init(slsConfigurationParameters: SAPFoundation.SLSConfigurationParameters, loginInputDelegate: any SAPFoundation.SLSLoginInputDelegate, identityStore: any SAPFoundation.UserIdentityStoring)
}
public enum SAPcpmsClientResourcesError : Swift.Error {
  case network
  case invalidHTTPStatus(statusCode: Swift.Int)
  case malformed
}
extension SAPFoundation.SAPcpmsClientResourcesError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public enum OAuth2TokenError : Foundation.LocalizedError, Swift.Equatable {
  case refreshTokenExpired
  case tokenNotAvailable
  public var errorDescription: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SAPFoundation.OAuth2TokenError, b: SAPFoundation.OAuth2TokenError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SAPCrashReporting {
  func initialiseCrashReporter() throws
  func uploadCrashFile(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
}
public class DefaultAPIKeyCredentialDiscovery : SAPFoundation.APIKeyCredentialDiscovery {
  public init()
  public init(using config: SAPFoundation.APIKeyAuthenticationConfig)
  public func provideAPIKeyCredential(for appplicationId: Swift.String?, user: Swift.String?) -> SAPFoundation.APIKeyCredential?
  @objc deinit
}
extension SAPFoundation.SAPURLSession {
  public enum CancellableDisposition {
    case allow
    case cancel(any Swift.Error)
  }
  public enum DataDisposition {
    case allow(Foundation.Data)
    case cancel(any Swift.Error)
  }
  public enum ResponseDisposition {
    case allow(Foundation.URLResponse)
    case cancel(any Swift.Error)
    case becomeDownload
    case resend
  }
  public enum RequestDisposition {
    case allow(Foundation.URLRequest)
    case cancel(any Swift.Error)
  }
  public enum DidCompleteDisposition {
    case allow
    case fail(any Swift.Error)
    case resend
  }
  public enum AuthChallengeDisposition {
    case use(Foundation.URLCredential)
    case rejectProtectionSpace
    case performDefaultHandling
    case cancel(any Swift.Error)
    case resend
  }
  public enum DelayedRequestDisposition {
    case continueLoading
    case use(new: Foundation.URLRequest)
    case cancel(any Swift.Error)
  }
  public enum InputStreamDisposition {
    case bypass
    case use(Foundation.InputStream)
    case cancel(any Swift.Error)
  }
  public enum HTTPRedirectDisposition {
    case allow(Foundation.URLRequest)
    case cancel(any Swift.Error)
  }
  public enum CacheResponseDisposition {
    case use(Foundation.CachedURLResponse?)
    case cancel(any Swift.Error)
  }
}
extension SAPFoundation.SAPURLSession {
  public struct HTTPHeader {
    public static let contentType: Swift.String
    public static let contentLength: Swift.String
    public static let accept: Swift.String
    public static let acceptLanguage: Swift.String
    public static let acceptCharset: Swift.String
  }
  public struct HTTPContentType {
    public static let applicationJSON: Swift.String
    public static let applicationData: Swift.String
    public static let applicationOctetStream: Swift.String
    public static let applicationXML: Swift.String
    public static let applicationPDF: Swift.String
    public static let audioMIDI: Swift.String
    public static let audioMPEG: Swift.String
    public static let audioOGG: Swift.String
    public static let audioWAV: Swift.String
    public static let audioWAVE: Swift.String
    public static let imageBMP: Swift.String
    public static let imageGIF: Swift.String
    public static let imageJPEG: Swift.String
    public static let imagePNG: Swift.String
    public static let imageSVGXML: Swift.String
    public static let multipartByteRanges: Swift.String
    public static let multipartFormData: Swift.String
    public static let textHTML: Swift.String
    public static let textPlain: Swift.String
    public static let videoMP4: Swift.String
    public static let videoOGG: Swift.String
  }
  public struct HTTPStatusCode {
    public static let ok: Swift.Int
    public static let created: Swift.Int
    public static let noContent: Swift.Int
    public static let notModified: Swift.Int
    public static let badRequest: Swift.Int
    public static let unauthorized: Swift.Int
    public static let forbidden: Swift.Int
    public static let notFound: Swift.Int
    public static let internalServerError: Swift.Int
  }
  public struct HTTPMethod {
    public static let delete: Swift.String
    public static let get: Swift.String
    public static let head: Swift.String
    public static let options: Swift.String
    public static let patch: Swift.String
    public static let post: Swift.String
    public static let put: Swift.String
  }
}
public class SLSUserIdentityDiscovery : SAPFoundation.UserIdentityObtaining {
  public init(slsConfigurationParameters: SAPFoundation.SLSConfigurationParameters, loginInputDelegate: any SAPFoundation.SLSLoginInputDelegate, sapURLSession: SAPFoundation.SAPURLSession = SAPURLSession())
  public func obtainUserIdentity(completionHandler: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
public let OTPParametersAuthorizationEndpointURL: Swift.String
public let OTPParametersFinishEndpointURL: Swift.String
public struct OTPParameters {
  public let authorizationEndpointURL: Foundation.URL
  public let finishEndpointURL: Foundation.URL
  public let challengeHeaderName: Swift.String
  public let challengeHeaderValue: Swift.String
  public init(authorizationEndpointURL: Foundation.URL, finishEndpointURL: Foundation.URL, challengeHeaderName: Swift.String = OTPChallengeHeaderName, challengeHeaderValue: Swift.String = OTPChallengeHeaderValue)
}
extension SAPFoundation.OTPParameters {
  public init(settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
}
extension SAPFoundation.OTPParameters : SAPFoundation.DiscoveryServiceConfigurable {
  public init(discoveryServiceConfig config: Any) throws
}
@_hasMissingDesignatedInitializers public class ClipboardProtectionEnforcer {
  public static var shared: SAPFoundation.ClipboardProtectionEnforcer {
    get
  }
  public func enforce(policy: SAPFoundation.ClipboardAccessPolicy = .blocked) throws
  public func getEnforcedPolicy() -> SAPFoundation.ClipboardAccessPolicy
  @objc deinit
}
@available(iOS 12.0, *)
public class ASWebAuthenticationSessionPresenter : SAPFoundation.ASWebAuthenticationSessionPresenting {
  weak public var delegate: (any SAPFoundation.WebViewPresenterDelegate)?
  public var callbackURLScheme: Swift.String?
  public var authenticationSession: AuthenticationServices.ASWebAuthenticationSession?
  public var webViewPresentingViewController: UIKit.UIViewController? {
    get
    set
  }
  public init(delegate: (any SAPFoundation.WebViewPresenterDelegate)? = nil, callbackURLScheme: Swift.String?)
  public func presentWebView(with url: Foundation.URL, sessionCompletionHandler: @escaping AuthenticationServices.ASWebAuthenticationSession.CompletionHandler, completionHandler: @escaping (AuthenticationServices.ASWebAuthenticationSession?, (any Swift.Error)?) -> Swift.Void)
  public func dismissWebView()
  public func reloadWebView()
  @objc deinit
}
public protocol ConfigurationProviding {
  var providerIdentifier: Swift.String { get }
  var expectedInput: [Swift.String : Any] { get }
  func provideConfiguration(input: [Swift.String : Any]) -> (providerSuccess: Swift.Bool, configuration: Foundation.NSDictionary, returnError: (any Swift.Error)?)
}
public protocol ConfigurationLoaderDelegate : AnyObject {
  func configurationProvider(_ provider: (any SAPFoundation.ConfigurationProviding)?, didCompleteWith result: Swift.Bool)
  func configurationProvider(_ provider: any SAPFoundation.ConfigurationProviding, didEncounter error: any Swift.Error)
  func configurationProvider(_ loader: SAPFoundation.ConfigurationLoader, requestedInput: [Swift.String : [Swift.String : Any]], completionHandler: @escaping (_ input: [Swift.String : [Swift.String : Any]]) -> Swift.Void)
}
public struct ConfigurationProviderNames {
  public static let managed: Swift.String
  public static let file: Swift.String
  public static let discoveryService: Swift.String
  public static let json: Swift.String
  public static let url: Swift.String
}
public let ConfigurationProviderUserDefaultsKey: Swift.String
public protocol ConfigurationPersisting {
  func persistConfiguration(_ configuration: [Swift.AnyHashable : Any])
  func resetPersistedConfiguration()
}
public struct ConfigurationProviderInputKeys : Swift.RawRepresentable {
  public typealias RawValue = Swift.String
  public let rawValue: SAPFoundation.ConfigurationProviderInputKeys.RawValue
  public init?(rawValue: SAPFoundation.ConfigurationProviderInputKeys.RawValue)
  public static let emailAddress: SAPFoundation.ConfigurationProviderInputKeys
  public static let onboardingCode: SAPFoundation.ConfigurationProviderInputKeys
  public static let JSONstring: SAPFoundation.ConfigurationProviderInputKeys
}
public struct SAPcpmsLockWipePolicy {
  public let lockDisconnectedPeriod: Swift.Int
  public let wipeDisconnectedPeriod: Swift.Int
  public init(lockDisconnectedPeriod: Swift.Int = 0, wipeDisconnectedPeriod: Swift.Int = 0)
}
extension SAPFoundation.SAPcpmsLockWipePolicy {
  public init?(sapcpmsSettings: Any) throws
  @available(*, deprecated, renamed: "init(sapcpmsLockWipePolicy:)")
  public init?(spcpmsLockWipeSettings: Any) throws
  public init?(sapcpmsLockWipePolicy: Any) throws
}
extension SAPFoundation.SAPcpmsLockWipePolicy : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public protocol OAuth2TokenStoreUserInfoTransforming {
  func toUserInfo() throws -> [Swift.String : Any]
  func apply(userInfo: [Swift.String : Any]) throws
}
extension SAPFoundation.OAuth2TokenStorage : SAPFoundation.OAuth2TokenStoreUserInfoTransforming {
  public func toUserInfo() throws -> [Swift.String : Any]
  public func apply(userInfo: [Swift.String : Any]) throws
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(SAPBTPSDKTelemetryService) public class TelemetryService : ObjectiveC.NSObject {
  @objc public static let shared: SAPFoundation.TelemetryService
  public var store: SAPFoundation.UsageStore? {
    get
  }
  public var sapcpmsSettingsParameters: SAPFoundation.SAPcpmsSettingsParameters? {
    get
    set
  }
  @objc deinit
  public func configure(urlSession: SAPFoundation.SAPURLSession, telemetryUploadKey: Swift.String, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  public func storeCustomEvent(key: Swift.String, date: Foundation.Date, duration: Swift.Double?) throws
}
extension SAPFoundation.TelemetryService : SAPFoundation.UserEventObserving {
  public func userAdded(with onboardingID: Foundation.UUID)
  public func userSwitched(to onboardingID: Foundation.UUID)
}
public enum SLSUserIdentityDiscoveryError : Swift.Error {
  case getCertificateAttributes
  case requestForSaltFailed
  case getCertificate(statusCode: Swift.Int, message: Swift.String)
  case invalidUserIdentity
  case authenticationFailed
}
extension SAPFoundation.SLSUserIdentityDiscoveryError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
open class OAuth2TokenStorage : SAPFoundation.OAuth2TokenStore {
  open var store: any SAPFoundation.CodableStoring
  open var keyHandler: (Foundation.URL) -> Swift.String
  public init(store: any SAPFoundation.CodableStoring, keyHandler: @escaping (Foundation.URL) -> Swift.String = OAuth2TokenStorage.key)
  open func store(token: SAPFoundation.OAuth2Token, for url: Foundation.URL) throws
  open func token(for url: Foundation.URL) throws -> SAPFoundation.OAuth2Token?
  open func deleteToken(for url: Foundation.URL) throws
  public static let keyPrefix: Swift.String
  public class func key(for url: Foundation.URL) -> Swift.String
  @objc deinit
}
open class NetworkActivityIndicatorObserver {
  public init()
  @objc deinit
}
extension SAPFoundation.NetworkActivityIndicatorObserver : SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCreate sessionTask: Foundation.URLSessionTask)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func copy() -> Any?
}
public func rootViewController() -> UIKit.UIViewController?
public protocol EventDispatching {
  func getEventDispatchingType() -> Swift.String
  func registerObserver(_ observer: any SAPFoundation.EventObserving)
  func unregisterObserver(_ observer: any SAPFoundation.EventObserving)
}
extension SAPFoundation.EventDispatching {
  public func getEventDispatchingType() -> Swift.String
}
public struct SAPcpmsNetworkSynchronizationPolicy {
  public let analytics: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public let clientResource: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public let logs: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public let offlineOData: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public init(analytics: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions = .default, clientResource: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions = .default, logs: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions = .default, offlineOData: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions = .default)
}
extension SAPFoundation.SAPcpmsNetworkSynchronizationPolicy {
  public init?(sapcpmsSettings: Any) throws
  public init?(sapcpmsNetworkPolicy: Any) throws
}
extension SAPFoundation.SAPcpmsNetworkSynchronizationPolicy : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class SecureDatabaseResultSet {
  public var query: Swift.String {
    get
  }
  @objc deinit
  public func close()
  public func next() throws -> Swift.Bool
  public var hasNext: Swift.Bool {
    get
  }
  public var columnCount: Swift.Int {
    get
  }
  public var columnNameToIndexMap: [Swift.String : Swift.Int] {
    get
  }
  public func columnIndex(forColumnName columnName: Swift.String) -> Swift.Int
  public func columnName(forColumnIndex columnIndex: Swift.Int) -> Swift.String?
  public func isColumnValueNull(forColumnIndex columnIndex: Swift.Int) -> Swift.Bool
  public func isColumnValueNull(forColumnName columnName: Swift.String) -> Swift.Bool
  public var row: [Swift.String : (any Foundation.NSCoding)?] {
    get
  }
  public func int(forColumnName columnName: Swift.String) -> Swift.Int?
  public func int(forColumnIndex columnIndex: Swift.Int) -> Swift.Int?
  public func int64(forColumnName columnName: Swift.String) -> Swift.Int64?
  public func int64(forColumnIndex columnIndex: Swift.Int) -> Swift.Int64?
  public func uint64(forColumnName columnName: Swift.String) -> Swift.UInt64?
  public func uint64(forColumnIndex columnIndex: Swift.Int) -> Swift.UInt64?
  public func double(forColumnName columnName: Swift.String) -> Swift.Double?
  public func double(forColumnIndex columnIndex: Swift.Int) -> Swift.Double?
  public func bool(forColumnName columnName: Swift.String) -> Swift.Bool?
  public func bool(forColumnIndex columnIndex: Swift.Int) -> Swift.Bool?
  public func string(forColumnName columnName: Swift.String) -> Swift.String?
  public func string(forColumnIndex columnIndex: Swift.Int) -> Swift.String?
  public func date(forColumnName columnName: Swift.String) -> Foundation.Date?
  public func date(forColumnIndex columnIndex: Swift.Int) -> Foundation.Date?
  public func data(forColumnName columnName: Swift.String) -> Foundation.Data?
  public func data(forColumnIndex columnIndex: Swift.Int) -> Foundation.Data?
  public func object<T>(forColumnName columnName: Swift.String) throws -> T? where T : SAPFoundation.SQLiteDatatypeBridgeable
  public func object<T>(forColumnIndex columnIndex: Swift.Int) throws -> T? where T : SAPFoundation.SQLiteDatatypeBridgeable
}
public protocol OAuth2TokenStore {
  func store(token: SAPFoundation.OAuth2Token, for url: Foundation.URL) throws
  func token(for url: Foundation.URL) throws -> SAPFoundation.OAuth2Token?
  func deleteToken(for url: Foundation.URL) throws
}
public enum SecureStorageError : Swift.Error {
  case openFailed(code: Swift.Int, message: Swift.String)
  case closed
  case authenticationFailed(message: Swift.String)
  case encryptionKeyChangeFailed(code: Swift.Int, message: Swift.String)
  case typeConversionFailed
  case backingStoreError(code: Swift.Int, message: Swift.String)
}
extension SAPFoundation.SecureStorageError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class SAPcpmsLogUploader {
  public static var logUploadEnabled: Swift.Bool {
    get
    set
  }
  public static var uploadLogInChunks: Swift.Bool {
    get
    set
  }
  public static var logLevel: SAPCommon.LogLevel {
    get
    set(loglevel)
  }
  public static var logExpiration: Swift.Int
  public static var defaultMaxFileSize: Swift.UInt64
  @available(*, deprecated, renamed: "defaultMaxFileNum")
  public static var defaultMaxBackups: Swift.Int
  public static var defaultMaxFileNum: Swift.Int {
    get
    set
  }
  public static func apply(sapcpmsLogSettings: SAPCommon.SAPcpmsLogSettings)
  public static func attachToRootLogger(maxFileSize: Swift.UInt64 = defaultMaxFileSize, maxFileNum: Swift.Int = defaultMaxFileNum) throws
  @available(*, deprecated, renamed: "attachToRootLogger(maxFileSize:maxFileNum:)")
  public static func attachToRootLogger(maxFileSize: Swift.UInt64, maxBackups: Swift.Int) throws
  public static func uploadLogs(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters, completionHandler: @escaping (_ error: SAPFoundation.SAPcpmsLogUploaderError?) -> Swift.Void = SAPcpmsLogUploader.defaultCompletionHandler)
  public static func uploadLogs(sapURLSession: SAPFoundation.SAPURLSession, endpoint: Foundation.URL, completionHandler: @escaping (_ error: SAPFoundation.SAPcpmsLogUploaderError?) -> Swift.Void = SAPcpmsLogUploader.defaultCompletionHandler)
  public static func deleteLogFiles() throws
  public static func defaultCompletionHandler(error: (any Swift.Error)?)
  @objc deinit
}
public enum SAPcpmsUserRolesError : Swift.Error {
  case invalidServerResponse
  case invalidHTTPStatus(statusCode: Swift.Int)
  case malformed(type: SAPFoundation.SAPcpmsUserRolesError.MalformedType, description: Swift.String)
  public enum MalformedType {
    case missingKey
    case invalidType
    public static func == (a: SAPFoundation.SAPcpmsUserRolesError.MalformedType, b: SAPFoundation.SAPcpmsUserRolesError.MalformedType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SAPFoundation.SAPcpmsUserRolesError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public class AuxiliaryDataRequest<T> : SAPFoundation.AuxiliaryDataRequestRepresenting, Swift.Codable where T : Swift.Decodable, T : Swift.Encodable {
  public typealias AuxDataRequestType = T
  public init(info: T, eSPAKAux: Foundation.Data, kind: Swift.String)
  public var eSPAKAuxiliary: Foundation.Data {
    get
    set
  }
  public var kind: Swift.String {
    get
    set
  }
  public var creationTime: Foundation.Date {
    get
    set
  }
  public var lastModifiedTime: Foundation.Date? {
    get
    set
  }
  public var completionTime: Foundation.Date? {
    get
    set
  }
  public func get() -> T
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public struct SAPcpmsFeature {
  public let pluginName: Swift.String
  public let displayName: Swift.String
  public let name: Swift.String
  public let featureDescription: Swift.String
  public let id: Swift.String
  public let whitelist: Swift.String
  public let jsModule: Swift.String
  public let version: Swift.String
}
extension SAPFoundation.SAPcpmsFeature : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public let OTPChallengeHeaderName: Swift.String
public let OTPChallengeHeaderValue: Swift.String
open class OTPObserver {
  final public let challengeHeaderName: Swift.String
  final public let challengeHeaderValue: Swift.String
  public init(authenticator: SAPFoundation.OTPAuthenticator, challengeHeaderName: Swift.String = OTPChallengeHeaderName, challengeHeaderValue: Swift.String = OTPChallengeHeaderValue)
  convenience public init(authenticationParameters: SAPFoundation.OTPParameters)
  convenience public init(settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  open func isChallenge(dataTask: SAPFoundation.SAPURLSessionTask, response: Foundation.URLResponse) -> Swift.Bool
  @objc deinit
}
extension SAPFoundation.OTPObserver : SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func copy() -> Any?
}
public class MeteringPassportManager : SAPFoundation.SAPPassportManaging {
  public init()
  open func getPassport() throws -> SAPFoundation.Passport
  open func setPassport(_ passport: SAPFoundation.Passport)
  open func clearPassport()
  public static var rootContextId: Foundation.UUID {
    get
  }
  @objc deinit
}
public enum OpenURLPolicyEnforcerError : Swift.Error {
  case failedToBlockUIApplicationOpen
  case failedToBlockUIApplicationCanOpenURL
  case failedToBlockUISceneOpen
  case failedToBlockUITextViewURLs
  public static func == (a: SAPFoundation.OpenURLPolicyEnforcerError, b: SAPFoundation.OpenURLPolicyEnforcerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.OpenURLPolicyEnforcerError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public enum UsageBrokerError : Swift.Error {
  case usageStoreInit
  case reporterInit
  case invalidUploadUrl
  case invalidUploadOnboardingID
  public static func == (a: SAPFoundation.UsageBrokerError, b: SAPFoundation.UsageBrokerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.UsageBrokerError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public protocol CodableCaching {
  associatedtype KeyType
  var costOfEntries: Swift.Double { get }
  var numberOfEntries: Swift.Int { get }
  func get<T>(_ type: T.Type, for key: Self.KeyType) throws -> T? where T : Swift.Decodable, T : Swift.Encodable
  func put<T>(_ value: T, for key: Self.KeyType, with cost: Swift.Double) throws where T : Swift.Decodable, T : Swift.Encodable
  func entry<T>(_ type: T.Type, for key: Self.KeyType) throws -> SAPFoundation.CacheEntry<T>? where T : Swift.Decodable, T : Swift.Encodable
  func remove(for key: Self.KeyType)
  func removeAllValues()
  func keys() throws -> Swift.AnySequence<Self.KeyType>
}
public enum AttestationError : Swift.Error, SAPCommon.SAPError {
  case attestationFailure(Swift.String)
  case assertionFailure(Swift.String)
  case attestationTokenFailure(Swift.String)
  case debugTokenPreconditionFailed(Swift.String)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
}
public class AttestationService {
  @objc deinit
  public init(sapCpmsSettingsParameters: SAPFoundation.SAPcpmsSettingsParameters, sapUrlSession: SAPFoundation.SAPURLSession, store: any SAPFoundation.CodableStoring, attestationSettings: SAPFoundation.SAPcpmsAttestationSettings, maxAppleServerFailureRetries: Swift.Int = 3) throws
  public static func getAttestationToken(from urlSession: SAPFoundation.SAPURLSession) throws -> Swift.String?
}
public struct CacheEntry<EntryValueType> {
}
public protocol Caching {
  associatedtype KeyType
  associatedtype ValueType
  var costOfEntries: Swift.Double { get }
  var numberOfEntries: Swift.Int { get }
  func set(value: Self.ValueType, forKey: Self.KeyType, withCost: Swift.Double)
  func value(forKey: Self.KeyType) -> Self.ValueType?
  func entry(forKey: Self.KeyType) -> SAPFoundation.CacheEntry<Self.ValueType>?
  func removeValue(forKey: Self.KeyType)
  func removeAllValues()
  func keys() -> Swift.AnySequence<Self.KeyType>
}
open class CodableStorage : SAPFoundation.CodableStoring {
  public init(store: any SAPCommon.DataStoring, coder: any SAPFoundation.CoderProtocol = PlistCoder())
  open func get<T>(_ type: T.Type, for key: Swift.String) throws -> T? where T : Swift.Decodable, T : Swift.Encodable
  open func put<T>(_ value: T, for key: Swift.String) throws where T : Swift.Decodable, T : Swift.Encodable
  open func remove(for key: Swift.String) throws
  public func keys() throws -> Swift.Set<Swift.String>
  @objc deinit
}
open class OAuth2Observer {
  public var authenticationHandler: (any SAPFoundation.AuthenticationHandling)?
  public init(authenticationParameters: SAPFoundation.OAuth2AuthenticationParameters, tokenStore: any SAPFoundation.OAuth2TokenStore)
  public init(authenticator: any SAPFoundation.OAuth2Authentication, tokenStore: any SAPFoundation.OAuth2TokenStore)
  open func isChallenge(dataTask: SAPFoundation.SAPURLSessionTask, response: Foundation.URLResponse) -> Swift.Bool
  @objc deinit
}
extension SAPFoundation.OAuth2Observer : SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.HTTPRedirectDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func copy() -> Any?
}
public struct SAPcpmsAttestationSettings {
  public let enabled: Swift.Bool
  public let enforced: Swift.Bool
  public init(enabled: Swift.Bool = false, enforced: Swift.Bool = false)
}
extension SAPFoundation.SAPcpmsAttestationSettings {
  public init(sapcpmsSettings: Any) throws
  public init(sapcpmsAttestationSettings: Any) throws
}
extension SAPFoundation.SAPcpmsAttestationSettings : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension SAPFoundation.SecureKeyValueStore : SAPCommon.DataStoring {
  public func put(data: Foundation.Data, for key: Swift.String) throws
  public func data(for key: Swift.String) throws -> Foundation.Data?
  public func removeData(for key: Swift.String) throws
}
open class SAPcpmsSettings {
  public enum SettingsTarget {
    case application
    case user
    case device
    public static func == (a: SAPFoundation.SAPcpmsSettings.SettingsTarget, b: SAPFoundation.SAPcpmsSettings.SettingsTarget) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(sapURLSession: SAPFoundation.SAPURLSession, applicationSettingsURL: Foundation.URL, userSettingsURL: Foundation.URL?, deviceSettingsURL: Foundation.URL?)
  public init(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  open func loadSAPcpmsSettings(completionHandler: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  open func load(settingsKeyPath: Swift.String? = nil, for settingsTarget: SAPFoundation.SAPcpmsSettings.SettingsTarget = .user, completionHandler: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  open func delete(settingsKeyPath: Swift.String, for settingsTarget: SAPFoundation.SAPcpmsSettings.SettingsTarget = .user, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void = SAPcpmsSettings.defaultCompletionHandler)
  open func store(settings: [Swift.String : Any], settingsKeyPath: Swift.String, for settingsTarget: SAPFoundation.SAPcpmsSettings.SettingsTarget = .user, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void = SAPcpmsSettings.defaultCompletionHandler)
  public static func defaultCompletionHandler(_ error: (any Swift.Error)?)
  @objc deinit
}
public protocol UserIdentityObtaining {
  func obtainUserIdentity(completionHandler: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
}
@objc public class SFSafariViewControllerPresenter : ObjectiveC.NSObject, SAPFoundation.SFSafariViewControllerPresenting, SafariServices.SFSafariViewControllerDelegate {
  weak public var delegate: (any SAPFoundation.WebViewPresenterDelegate)?
  public var safariViewController: SafariServices.SFSafariViewController?
  public var webViewPresentingViewController: UIKit.UIViewController? {
    get
    set
  }
  public init(delegate: (any SAPFoundation.WebViewPresenterDelegate)? = nil)
  public func presentWebView(with url: Foundation.URL, completionHandler: @escaping (SafariServices.SFSafariViewController?, (any Swift.Error)?) -> Swift.Void)
  public func dismissWebView()
  @objc public func safariViewControllerDidFinish(_ controller: SafariServices.SFSafariViewController)
  @objc deinit
}
public class CryptoProviderUtil {
  public init()
  public func encrypt(data: Foundation.Data, using key: Foundation.Data) throws -> Foundation.Data
  public func decrypt(data: Foundation.Data, using key: Foundation.Data) throws -> Foundation.Data
  @objc deinit
}
public protocol CSRFTokenStoring {
  func store(token: Swift.String, for url: Foundation.URL) throws
  func token(for url: Foundation.URL) throws -> Swift.String?
  func deleteToken(for url: Foundation.URL) throws
}
public enum SAPcpmsRemoteNotificationError : Swift.Error {
  case emptyDeviceToken
  case networkCommunicationFailed(error: (any Swift.Error)?, httpStatuscode: Swift.Int?, response: Swift.String?)
  case notificationIDMissing
  case feedbackUrlMissing
  case invalidArguments(error: (any Swift.Error)?)
  case invalidHTTPStatus(statusCode: Swift.Int)
  case characterLimitReachedOrMaxTopicsSubscribed
  case deviceandUserNotRegisteredforPush
  case malformed(type: SAPFoundation.SAPcpmsRemoteNotificationError.MalformedType, description: Swift.String)
  public enum MalformedType {
    case missingKey
    case invalidType
    public static func == (a: SAPFoundation.SAPcpmsRemoteNotificationError.MalformedType, b: SAPFoundation.SAPcpmsRemoteNotificationError.MalformedType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SAPFoundation.SAPcpmsRemoteNotificationError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public let OAuth2AuthenticationParametersAuthorizationEndpointURL: Swift.String
public let OAuth2AuthenticationParametersRedirectURL: Swift.String
public let OAuth2AuthenticationParametersTokenEndpointURL: Swift.String
public let OAuth2AuthenticationParametersClientID: Swift.String
public let OAuth2AuthenticationParametersClientSecret: Swift.String
public let OAuth2AuthenticationParametersScope: Swift.String
public let OAuth2AuthenticationParametersState: Swift.String
public let OAuth2AuthenticationParametersxsuaaURL: Swift.String
public struct OAuth2AuthenticationParameters {
  public let authorizationEndpointURL: Foundation.URL
  public let tokenEndpointURL: Foundation.URL
  public let redirectURL: Foundation.URL
  public let clientID: Swift.String
  public let clientSecret: Swift.String?
  public let xsuaaAuthorizationURL: Foundation.URL?
  public let requestingScopes: Swift.Set<Swift.String>
  public let state: Swift.String?
  public let codeChallengeMethod: Swift.String
  public init(authorizationEndpointURL: Foundation.URL, clientID: Swift.String, redirectURL: Foundation.URL, tokenEndpointURL: Foundation.URL, requestingScopes: Swift.Set<Swift.String> = [], state: Swift.String? = nil, clientSecret: Swift.String? = nil, xsuaaAuthorizationURL: Foundation.URL? = nil, codeChallengeMethod: Swift.String = "S256")
}
public let OAuth2AuthenticationParametersDiscoveryServiceAuthType: Swift.String
public let OAuth2AuthenticationParametersDiscoveryServiceAuthorizationEndpointURL: Swift.String
public let OAuth2AuthenticationParametersDiscoveryServiceTokenEndpointURL: Swift.String
public let OAuth2AuthenticationParametersDiscoveryServiceEndUserUIURL: Swift.String
public let OAuth2AuthenticationParametersDiscoveryServiceClients: Swift.String
public let OAuth2AuthenticationParametersDiscoveryServiceClientID: Swift.String
public let OAuth2AuthenticationParametersDiscoveryServiceRedirectURL: Swift.String
public let OAuth2AuthenticationParametersDiscoveryServicexsuaaAuthorizationURL: Swift.String
public let OAuth2AuthenticationParametersDiscoveryServiceGrantType: Swift.String
public let OAuth2PKCEAuthenticationParameters: Swift.String
public let OAuth2PKCEAuthenticationParametersCodeChallengeMethod: Swift.String
extension SAPFoundation.OAuth2AuthenticationParameters : SAPFoundation.DiscoveryServiceConfigurable {
  public init(discoveryServiceConfig config: Any) throws
  public init(config: Any) throws
}
public class SAMLAuthenticator : SAPFoundation.SAMLAuthentication {
  public init(authenticationParameters: SAPFoundation.SAMLAuthenticationParameters, webViewPresenter: any SAPFoundation.WKWebViewPresenting)
  convenience public init(settingsParameters: SAPFoundation.SAPcpmsSettingsParameters, webViewPresenter: any SAPFoundation.WKWebViewPresenting)
  public func authenticate(session: SAPFoundation.SAPURLSession, completionHandler: @escaping (_ error: (any Swift.Error)?) -> Swift.Void = SAMLAuthenticator.defaultCompletionHandler)
  public func authenticate(cookies: [Foundation.HTTPCookie], completionHandler: @escaping (_ credentials: [Foundation.HTTPCookie]?, _ error: (any Swift.Error)?) -> Swift.Void)
  public func cancelAuthentication()
  public static func defaultCompletionHandler(error: (any Swift.Error)?)
  @objc deinit
}
extension SAPFoundation.OAuth2Observer {
  @available(iOSApplicationExtension, unavailable)
  convenience public init(clientCredentialsAuthenticationParameters authenticationParameters: SAPFoundation.OAuth2ClientCredentialsAuthenticationParameters, tokenStore: any SAPFoundation.OAuth2TokenStore)
}
public struct SAPcpmsSecurityPolicy {
  public let deviceComplianceDetectionPolicy: SAPFoundation.DeviceComplianceDetectionPolicy
  public let clipboardAccessPolicy: SAPFoundation.ClipboardAccessPolicy
  public let printPolicy: SAPFoundation.PrintPolicy
  public let openURLPolicy: SAPFoundation.OpenURLPolicy
  public init(deviceComplianceDetectionPolicy: SAPFoundation.DeviceComplianceDetectionPolicy = .ignore, clipboardAccessPolicy: SAPFoundation.ClipboardAccessPolicy = .unrestricted, printPolicy: SAPFoundation.PrintPolicy = .unrestricted, openURLPolicy: SAPFoundation.OpenURLPolicy = .unrestricted)
}
extension SAPFoundation.SAPcpmsSecurityPolicy {
  public init?(sapcpmsSettings: Any) throws
  public init?(sapcpmsSecurityPolicy: Any) throws
}
extension SAPFoundation.SAPcpmsSecurityPolicy : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class SceneManager {
  public static let shared: SAPFoundation.SceneManager
  final public let isMultiWindowSupportEnabled: Swift.Bool
  public func setCurrentSceneSessionID(id: Swift.String)
  public func setOnboardingSceneSessionID(id: Swift.String)
  public func getCurrentSceneSessionID() -> Swift.String?
  public func getOnboardingSceneSessionID() -> Swift.String?
  public static func getScene(sessionID: Swift.String) -> UIKit.UIScene?
  public func getCurrentOnboardingScene() -> UIKit.UIScene?
  public func getCurrentOnboardingWindow() -> UIKit.UIWindow?
  @objc deinit
}
public struct UsageDataCollectionItems : Swift.OptionSet {
  public var rawValue: Swift.Int {
    get
  }
  public static let deviceItems: SAPFoundation.UsageDataCollectionItems
  public static let memoryItems: SAPFoundation.UsageDataCollectionItems
  public static let networkingItems: SAPFoundation.UsageDataCollectionItems
  public static let all: SAPFoundation.UsageDataCollectionItems
  public static let none: SAPFoundation.UsageDataCollectionItems
  public init(rawValue items: Swift.Int)
  public typealias ArrayLiteralElement = SAPFoundation.UsageDataCollectionItems
  public typealias Element = SAPFoundation.UsageDataCollectionItems
  public typealias RawValue = Swift.Int
}
public enum SAPcpmsDestinationsError : Swift.Error {
  case invalidServerResponse
  case invalidHTTPStatus(statusCode: Swift.Int)
  case decodingFailed(error: any Swift.Error)
  case malformed(type: SAPFoundation.SAPcpmsDestinationsError.MalformedType, description: Swift.String)
  public enum MalformedType {
    case missingKey
    case invalidType
    public static func == (a: SAPFoundation.SAPcpmsDestinationsError.MalformedType, b: SAPFoundation.SAPcpmsDestinationsError.MalformedType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SAPFoundation.SAPcpmsDestinationsError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public protocol UserEventObserving : SAPFoundation.EventObserving {
  func userAdded(with onboardingID: Foundation.UUID)
  func userSwitched(to onboardingID: Foundation.UUID)
}
public struct OAuth2Token {
  public let accessToken: Swift.String
  public let tokenType: Swift.String
  public let scopes: Swift.Set<Swift.String>
  public let expiryDate: Foundation.Date?
  public let refreshToken: Swift.String?
  public init(accessToken: Swift.String, tokenType: Swift.String, expiryDate: Foundation.Date? = nil, scopes: Swift.Set<Swift.String> = [], refreshToken: Swift.String? = nil)
}
extension SAPFoundation.OAuth2Token : Swift.Equatable {
  public static func == (lhs: SAPFoundation.OAuth2Token, rhs: SAPFoundation.OAuth2Token) -> Swift.Bool
}
extension SAPFoundation.OAuth2Token : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class NetworkActivityIndicatorController {
  public static var shared: SAPFoundation.NetworkActivityIndicatorController {
    get
  }
  public func shouldShowActivityIndicator()
  public func shouldHideActivityIndicator()
  @objc deinit
}
public enum ComponentType : Swift.Int16 {
  case BROWSER
  case TRACELIB
  case WEBAS
  case J2EE
  case TREX
  case ICM
  case GATEWAY
  case CPIC
  case DOTNET
  case ECLIPSE
  case PI_FOR_SAP_SENDER
  case SCP_FOR_NONSAP_SENDER
  case PI_FOR_NONSAP_SENDER
  case SAP_PARTNER
  case SCP_REQUEST_OR_DETERMINATION_LATER_IN_PROCESSING
  case S4
  case SFSF
  case ARIBA
  case CONCUR
  case FIELDGLASS
  case CALLIDUS
  case BYD
  case IBP
  case HYBRIS
  case SMB_B1
  case INDUSTRY_CLOUD
  case LEONARDO
  case CUSTOMER_CHECKOUT
  case COPILOT
  public init?(rawValue: Swift.Int16)
  public typealias RawValue = Swift.Int16
  public var rawValue: Swift.Int16 {
    get
  }
}
public enum TraceFlags : Swift.Int16 {
  case SAPTRACELEVEL_SQL
  case SAPTRACELEVEL_BUFFER
  case SAPTRACELEVEL_ENQUEU
  case SAPTRACELEVEL_RFC
  case SAPTRACELEVEL_PERMISSION
  case SAPTRACELEVEL_FREE
  case SAPTRACELEVEL_CFUNCTION
  case DSR_ABAP_TRACE_FLAG
  case SAPTRACELEVEL_ABAPCONDENS0
  case SAPTRACELEVEL_ABAPCONDENS1
  case DSR_SAT_TRACE_FLAG
  case ESP_WEBSERVICE_FLAG
  case HTTP
  case TRCLVL_NONE
  case TRCLVL_LOW
  case TRCLVL_MEDIUM
  case TRCLVL_HIGH
  public init?(rawValue: Swift.Int16)
  public typealias RawValue = Swift.Int16
  public var rawValue: Swift.Int16 {
    get
  }
}
@_hasMissingDesignatedInitializers public class Passport {
  public func toString() -> Swift.String
  public class PassportBuilder {
    public init()
    public func actionName(_ newValue: Swift.String) throws -> SAPFoundation.Passport.PassportBuilder
    public func traceFlag(_ newValue: SAPFoundation.TraceFlags) -> SAPFoundation.Passport.PassportBuilder
    public func userId(_ newValue: Swift.String) throws -> SAPFoundation.Passport.PassportBuilder
    public func componentName(_ newValue: Swift.String) throws -> SAPFoundation.Passport.PassportBuilder
    public func prevComponentName(_ newValue: Swift.String) throws -> SAPFoundation.Passport.PassportBuilder
    public func componentType(_ newValue: SAPFoundation.ComponentType) -> SAPFoundation.Passport.PassportBuilder
    public func transactionId(_ newValue: Foundation.UUID) -> SAPFoundation.Passport.PassportBuilder
    public func rootContextId(_ newValue: Foundation.UUID) -> SAPFoundation.Passport.PassportBuilder
    public func build() throws -> SAPFoundation.Passport
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class FileConfigurationProvider : SAPFoundation.ConfigurationProviding {
  public var filename: Swift.String {
    get
  }
  public init(_ configurationFilename: Swift.String = "ConfigurationProvider")
  public var providerIdentifier: Swift.String {
    get
  }
  public var expectedInput: [Swift.String : Any] {
    get
  }
  public func provideConfiguration(input: [Swift.String : Any] = [:]) -> (providerSuccess: Swift.Bool, configuration: Foundation.NSDictionary, returnError: (any Swift.Error)?)
  @objc deinit
}
public class CSRFTokenObserver : SAPFoundation.SAPURLSessionObserving {
  convenience public init(rootUrl: Foundation.URL, tokenStore: any SAPFoundation.CSRFTokenStoring = CSRFTokenStorage(store: CompositeStorage()))
  public init(tokenUrlProvider: any SAPFoundation.CSRFTokenURLProviding, tokenStore: any SAPFoundation.CSRFTokenStoring = CSRFTokenStorage(store: CompositeStorage()))
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  public func copy() -> Any?
  @objc deinit
}
extension SAPCommon.SAPcpmsUsage {
  public class func sessionStart(settingsParameters settings: SAPFoundation.SAPcpmsSettingsParameters)
}
extension SAPCommon.SAPcpmsRecord {
  public class func sessionStart(settingsParameters settings: SAPFoundation.SAPcpmsSettingsParameters) -> SAPCommon.UsageRecord
}
public protocol AuxiliaryDataContainerRepresenting : Swift.Decodable, Swift.Encodable {
  associatedtype AuxDataType : Swift.Decodable, Swift.Encodable
  var lastModified: Foundation.Date { get set }
  var creationTime: Foundation.Date { get set }
  func get() -> Self.AuxDataType
}
@_hasMissingDesignatedInitializers open class DiscoveryServiceConfigurationProvider : SAPFoundation.ConfigurationProviding {
  convenience public init()
  public init(applicationID: Swift.String? = nil, discoveryServiceHost: Swift.String? = nil)
  public var providerIdentifier: Swift.String {
    get
  }
  public var expectedInput: [Swift.String : Any] {
    get
  }
  public func provideConfiguration(input: [Swift.String : Any] = [:]) -> (providerSuccess: Swift.Bool, configuration: Foundation.NSDictionary, returnError: (any Swift.Error)?)
  @objc deinit
}
public class AuxiliaryKeyContainer<T> : SAPFoundation.AuxiliaryKeyContainerRepresenting where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Hashable {
  public typealias AuxKeyType = T
  public init(key: T)
  public func get() -> T
  public static func == (lhs: SAPFoundation.AuxiliaryKeyContainer<T>, rhs: SAPFoundation.AuxiliaryKeyContainer<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
}
public enum BasicCredentialDiscoveryError : Swift.Error {
  case cancelled
  case inconsistentState
  public static func == (a: SAPFoundation.BasicCredentialDiscoveryError, b: SAPFoundation.BasicCredentialDiscoveryError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.BasicCredentialDiscoveryError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public protocol AppDelegateObserving : SAPFoundation.EventObserving {
  func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  func application(_ application: UIKit.UIApplication, continue userActivity: Foundation.NSUserActivity, restorationHandler: @escaping ([any UIKit.UIUserActivityRestoring]?) -> Swift.Void) -> Swift.Bool
  func application(_ application: UIKit.UIApplication, handleEventsForBackgroundURLSession identifier: Swift.String, completionHandler: @escaping () -> Swift.Void)
}
extension SAPFoundation.AppDelegateObserving {
  public func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  public func application(_ application: UIKit.UIApplication, continue userActivity: Foundation.NSUserActivity, restorationHandler: @escaping ([any UIKit.UIUserActivityRestoring]?) -> Swift.Void) -> Swift.Bool
  public func application(_ application: UIKit.UIApplication, handleEventsForBackgroundURLSession identifier: Swift.String, completionHandler: @escaping () -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class DispatcherFactory {
  public static func getConfiguredAppEventDispatcher() -> any SAPFoundation.EventDispatching
  @objc deinit
}
public struct JWS {
  public let jwsPayload: Foundation.Data!
  public init(serializedJWS jws: Swift.String) throws
}
extension SAPFoundation.JWS {
  public static func isSupported(algorithm: Swift.String) throws -> Swift.Bool
}
extension SAPFoundation.JWS : SAPFoundation.DigitallySignedMessage {
  public var payload: Foundation.Data {
    get
  }
  public var algorithm: SAPFoundation.DigitalSignatureAlgorithm {
    get
  }
  public var signature: Foundation.Data {
    get
  }
}
@_hasMissingDesignatedInitializers public class SAPCrashReporter {
  public static let shared: SAPFoundation.SAPCrashReporter
  @objc deinit
}
extension SAPFoundation.SAPCrashReporter : SAPFoundation.SAPCrashReporting {
  public func initialiseCrashReporter()
  public func uploadCrashFile(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
}
public protocol BasicCredentialDiscovery : AnyObject {
  func provideBasicCredential(for url: Foundation.URL, challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (SAPFoundation.BasicCredential?, (any Swift.Error)?) -> Swift.Void)
}
public class MemoryDataStorage : SAPCommon.DataStoring {
  public init()
  public func put(data: Foundation.Data, for key: Swift.String) throws
  public func data(for key: Swift.String) throws -> Foundation.Data?
  public func removeData(for key: Swift.String) throws
  public func keys() throws -> Swift.Set<Swift.String>
  @objc deinit
}
open class MemoryCache<Key, Value> : SAPFoundation.Caching where Key : Swift.Hashable {
  public typealias KeyType = Key
  public typealias ValueType = Value
  public typealias MemoryCacheEntry = SAPFoundation.CacheEntry<Value>
  final public let maximumNumberOfEntries: Swift.Int
  final public let maximumCost: Swift.Double
  required public init(maximumNumberOfEntries: Swift.Int = 0, maximumCost: Swift.Double = 0, clearCacheOnMemoryWarning clearOnMemWarning: Swift.Bool = true)
  @objc deinit
  open var costOfEntries: Swift.Double {
    get
  }
  open var numberOfEntries: Swift.Int {
    get
  }
  open func set(value: Value, forKey key: Key, withCost cost: Swift.Double = 0)
  open func entry(forKey key: Key) -> SAPFoundation.CacheEntry<Value>?
  open func value(forKey key: Key) -> Value?
  open func removeAllValues()
  open func removeValue(forKey key: Key)
  open func keys() -> Swift.AnySequence<SAPFoundation.MemoryCache<Key, Value>.KeyType>
}
extension SAPFoundation.OAuth2Authenticator {
  convenience public init(passwordAuthenticationParameters: SAPFoundation.OAuth2PasswordAuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession())
  convenience public init(passwordAuthenticationParameters: SAPFoundation.OAuth2PasswordAuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession(), webViewPresenter: any SAPFoundation.WKWebViewPresenting)
  convenience public init(passwordAuthenticationParameters: SAPFoundation.OAuth2PasswordAuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession(), webViewPresenter: any SAPFoundation.SFSafariViewControllerPresenting)
  convenience public init(passwordAuthenticationParameters: SAPFoundation.OAuth2PasswordAuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession(), webViewPresenter: any SAPFoundation.ASWebAuthenticationSessionPresenting)
}
open class CompositeCache<CompositeCacheKeyType, CompositeCacheValueType> : SAPFoundation.Caching {
  public typealias KeyType = CompositeCacheKeyType
  public typealias ValueType = CompositeCacheValueType
  public init()
  open func addCache<C>(_ cache: C) where CompositeCacheKeyType == C.KeyType, CompositeCacheValueType == C.ValueType, C : SAPFoundation.Caching
  open var costOfEntries: Swift.Double {
    get
  }
  open var numberOfEntries: Swift.Int {
    get
  }
  open func keys() -> Swift.AnySequence<SAPFoundation.CompositeCache<CompositeCacheKeyType, CompositeCacheValueType>.KeyType>
  open func set(value: SAPFoundation.CompositeCache<CompositeCacheKeyType, CompositeCacheValueType>.ValueType, forKey key: SAPFoundation.CompositeCache<CompositeCacheKeyType, CompositeCacheValueType>.KeyType, withCost cost: Swift.Double = 0)
  open func value(forKey key: SAPFoundation.CompositeCache<CompositeCacheKeyType, CompositeCacheValueType>.KeyType) -> SAPFoundation.CompositeCache<CompositeCacheKeyType, CompositeCacheValueType>.ValueType?
  open func entry(forKey key: SAPFoundation.CompositeCache<CompositeCacheKeyType, CompositeCacheValueType>.KeyType) -> SAPFoundation.CacheEntry<CompositeCacheValueType>?
  open func removeValue(forKey key: SAPFoundation.CompositeCache<CompositeCacheKeyType, CompositeCacheValueType>.KeyType)
  open func removeAllValues()
  @objc deinit
}
open class SAPcpmsClientResources {
  public init(sapURLSession: SAPFoundation.SAPURLSession, clientResourcesURL: Foundation.URL)
  convenience public init(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  open func downloadResource(named: Swift.String? = nil, version: Swift.String? = nil, completionHandler: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  open func downloadResource(named: Swift.String? = nil, version: Swift.String? = nil, toFile: Foundation.URL, canOverwrite: Swift.Bool = true, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  open func fetchResourceInfo(completionHandler: @escaping ([SAPFoundation.ResourceInfo]?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
public class SecureDatabaseQueue {
  public var databaseStore: SAPFoundation.SecureDatabaseStore {
    get
  }
  public init(databaseStore: SAPFoundation.SecureDatabaseStore)
  public func inDatabase(_ block: @escaping (_ db: SAPFoundation.SecureDatabaseStore) throws -> Swift.Void) throws
  public func inExclusiveTransaction(_ block: (_ db: SAPFoundation.SecureDatabaseStore) throws -> Swift.Bool) throws
  public func inDeferredTransaction(_ block: (_ db: SAPFoundation.SecureDatabaseStore) throws -> Swift.Bool) throws
  @objc deinit
}
public struct OAuth2PasswordAuthenticationParameters {
  public let authorizationEndpointURL: Foundation.URL
  public let tokenEndpointURL: Foundation.URL
  public let redirectURL: Foundation.URL
  public let clientID: Swift.String
  public let passcode: Swift.String
  public init(authorizationEndpointURL: Foundation.URL, clientID: Swift.String, redirectURL: Foundation.URL, tokenEndpointURL: Foundation.URL, passcode: Swift.String)
  public var authenticationParameters: SAPFoundation.OAuth2AuthenticationParameters {
    get
  }
}
extension SAPFoundation.OAuth2PasswordAuthenticationParameters : SAPFoundation.DiscoveryServiceConfigurable {
  public enum DiscoveryServiceConstants {
  }
  public init(discoveryServiceConfig config: Any) throws
  public init(config: Any) throws
}
@_hasMissingDesignatedInitializers public class SceneDelegateDispatcher : SAPFoundation.EventDispatching {
  public static func getObservers() -> [Swift.String : any SAPFoundation.SceneDelegateObserving]
  public static func getObserver(scene sessionID: Swift.String) -> (any SAPFoundation.SceneDelegateObserving)?
  public static func scene(_ scene: UIKit.UIScene, openURLContexts URLContexts: Swift.Set<UIKit.UIOpenURLContext>)
  public static func scene(_ scene: UIKit.UIScene, willConnectTo session: UIKit.UISceneSession, options connectionOptions: UIKit.UIScene.ConnectionOptions)
  public static func scene(_ scene: UIKit.UIScene, continue userActivity: Foundation.NSUserActivity)
  public static func sceneDidDisconnect(_ scene: UIKit.UIScene)
  public static func sceneWillEnterForeground(_ scene: UIKit.UIScene)
  public static func sceneDidEnterBackground(_ scene: UIKit.UIScene)
  public static func register(scene sessionID: Swift.String? = nil, _ observer: any SAPFoundation.SceneDelegateObserving)
  public static func unregister(_ observer: any SAPFoundation.SceneDelegateObserving)
  public func registerObserver(_ observer: any SAPFoundation.EventObserving)
  public func unregisterObserver(_ observer: any SAPFoundation.EventObserving)
  @objc deinit
}
public class AuxiliaryCommunicationProvider : SAPFoundation.AuxiliaryCommunicationProviding {
  public init(using store: any SAPCommon.DataStoring, context: [Swift.String : Any] = [String: Any]())
  public var context: [Swift.String : Any] {
    get
    set
  }
  public func put(data: Foundation.Data, for key: Swift.String) throws
  public func get(for key: Swift.String) throws -> Foundation.Data?
  public func delete(for key: Swift.String) throws
  @objc deinit
}
public enum SAPcpmsDeviceSecurityUploadError : Swift.Error {
  case network
  case invalidHTTPStatus(statusCode: Swift.Int)
  case invalidPayload
  case missingDeviceRegistration
}
extension SAPFoundation.SAPcpmsDeviceSecurityUploadError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public enum ClipboardAccessPolicy : Swift.String {
  case blocked
  case unrestricted
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class UsageStore : SAPCommon.UsageStoring {
  public static let unattributedStorageID: Swift.String
  public static let defaultFolderURL: Foundation.URL
  public var storageID: Swift.String {
    get
  }
  public var initTimestamp: Foundation.Date {
    get
  }
  public init(with path: Foundation.URL = defaultFolderURL, storageID: Foundation.UUID? = nil, encryptionKey: Swift.String? = nil) throws
  public func removeRecords(before date: Foundation.Date = Date(), after end: Foundation.Date? = nil, targetID: Swift.String)
  public func snapshot(for targetID: Swift.String) -> any SAPCommon.UsageSnapshotting
  public func snapshot(for targetID: Swift.String, till date: Foundation.Date?) -> any SAPCommon.UsageSnapshotting
  public func records(filter: SAPCommon.UsageRecordFilter, _ body: (SAPCommon.UsageRecord) -> Swift.Bool)
  public func store(record: SAPCommon.UsageRecord, for targetID: Swift.String)
  public func targetIdentifiers() -> [Swift.String]
  public func removeRecords(using snapshot: any SAPCommon.UsageSnapshotting)
  public func records(for snapshot: any SAPCommon.UsageSnapshotting, _ body: (SAPCommon.UsageRecord) -> Swift.Bool)
  public func recordCount(for snapshot: any SAPCommon.UsageSnapshotting) -> Swift.Int
  @objc deinit
}
public enum OAuth2Error : Swift.Error {
  case server(error: SAPFoundation.OAuth2ServerError)
  case webView(error: any Swift.Error)
  case invalidArgument(detail: Swift.String)
  case http(error: any Swift.Error, statusCode: Swift.Int?, response: Swift.String?)
  case missingHTTPResponse
  case parse(error: Swift.String, httpUrlResponse: Foundation.HTTPURLResponse, data: Foundation.Data)
  case authenticationInProgress
  case authorizationCode
  case tokenRejected
  case backgroundAuthentication
  case cancelled
  case webViewReloaded
}
extension SAPFoundation.OAuth2Error : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public let SecureStoreDefaultStoreName: Swift.String
public let OAuth2ClientCredentialsAuthenticationParametersTokenEndpointURL: Swift.String
public let OAuth2ClientCredentialsAuthenticationParametersName: Swift.String
public let OAuth2ClientCredentialsAuthenticationParametersSecret: Swift.String
public let OAuth2ClientCredentialsAuthenticationParametersScope: Swift.String
public struct OAuth2ClientCredentialsAuthenticationParameters {
  public let tokenEndpointURL: Foundation.URL
  public let requestingScopes: Swift.Set<Swift.String>
  public let clientCredentialsHandler: (Foundation.URLRequest) throws -> Foundation.URLRequest
  public init(tokenEndpointURL: Foundation.URL, requestingScopes: Swift.Set<Swift.String> = [], clientCredentialsHandler: @escaping (Foundation.URLRequest) throws -> Foundation.URLRequest)
  public init(tokenEndpointURL: Foundation.URL, requestingScopes: Swift.Set<Swift.String> = [], name: Swift.String, secret: Swift.String)
}
extension SAPFoundation.OAuth2ClientCredentialsAuthenticationParameters : SAPFoundation.DiscoveryServiceConfigurable {
  public init(discoveryServiceConfig config: Any) throws
}
public protocol CSRFTokenURLProviding {
  func csrfTokenURL(for: Foundation.URL) -> Foundation.URL
}
@_hasMissingDesignatedInitializers public class OpenURLPolicyEnforcer {
  public static var shared: SAPFoundation.OpenURLPolicyEnforcer {
    get
  }
  public func enforce(policy: SAPFoundation.OpenURLPolicy = .blocked) throws
  public func getOpenURLPolicy() -> SAPFoundation.OpenURLPolicy
  @objc deinit
}
open class SAPcpmsDestinations {
  public init(sapURLSession: SAPFoundation.SAPURLSession, destinationsServiceUrl: Foundation.URL)
  convenience public init(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  open func load(completionHandler: @escaping ([Swift.String : Swift.String]?, (any Swift.Error)?) -> Swift.Void)
  open func load(to settingsParameters: SAPFoundation.SAPcpmsSettingsParameters, completionHandler: @escaping (SAPFoundation.SAPcpmsSettingsParameters?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConnectivityReceiver {
  public static var observers: [any SAPFoundation.ConnectivityObserver]
  public static func registerObserver(_ observer: any SAPFoundation.ConnectivityObserver)
  public static func unregisterObserver(_ observer: any SAPFoundation.ConnectivityObserver)
  @objc deinit
}
public protocol SLSLoginInputDelegate : AnyObject {
  func slsUserIdentityDiscovery(_ sls: SAPFoundation.SLSUserIdentityDiscovery, needsInputForLogin: SAPFoundation.SLSLoginInput, completionHandler: @escaping ([SAPFoundation.SLSLoginInputFieldValue]?, (any Swift.Error)?) -> Swift.Void)
  func slsUserIdentityDiscoveryDidFinishReceivingInput(_ sls: SAPFoundation.SLSUserIdentityDiscovery)
}
public let AttestationTokenMissingValue: Swift.String
public let AttestationTokenErrorHeaderName: Swift.String
public class AttestationObserver {
  @objc deinit
  public init(attestationService: SAPFoundation.AttestationService)
  public func reset()
}
extension SAPFoundation.AttestationObserver : SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
}
public class SAPcpmsAuthenticationManager : SAPFoundation.AuthenticationHandling {
  weak public var delegate: (any SAPFoundation.AuthenticationDelegate)?
  final public let roleServiceURL: Foundation.URL
  final public let store: any SAPFoundation.CodableStoring
  final public let currentUserIDKey: Swift.String
  public init(roleServiceURL: Foundation.URL, store: any SAPFoundation.CodableStoring, delegate: (any SAPFoundation.AuthenticationDelegate)?, internalAuthenticationDelegate: (any SAPFoundation.AuthenticationDelegate)? = nil)
  convenience public init(settingsParameters: SAPFoundation.SAPcpmsSettingsParameters, store: any SAPFoundation.CodableStoring, delegate: (any SAPFoundation.AuthenticationDelegate)?, internalAuthenticationDelegate: (any SAPFoundation.AuthenticationDelegate)? = nil)
  public func authenticationObserver(_ observer: any SAPFoundation.SAPURLSessionObserving, didAuthenticate session: SAPFoundation.SAPURLSession, requestBypassIdentifier: Foundation.UUID, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func authenticationObserver(_ observer: any SAPFoundation.SAPURLSessionObserving, didFailToAuthenticate session: SAPFoundation.SAPURLSession, error: any Swift.Error)
  @objc deinit
}
public struct SAPcpmsUsagePolicy {
  public let uploadDataAfterDays: Swift.Int
  public let crashLogUploadEnabled: Swift.Bool
  public let dataCollectionEnabled: Swift.Bool
  public init(dataCollectionEnabled: Swift.Bool = false, uploadDataAfterDays: Swift.Int = 0, crashLogUploadEnabled: Swift.Bool = false)
}
extension SAPFoundation.SAPcpmsUsagePolicy {
  public init?(sapcpmsSettings: Any) throws
  public init?(sapcpmsUsagePolicy: Any) throws
}
extension SAPFoundation.SAPcpmsUsagePolicy : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public enum ConfigurationError : Swift.Error {
  case missingKey(Swift.String, source: Swift.String)
  case invalidValue(Swift.String, source: Swift.String)
  case invalidStructure(detail: Swift.String, source: Swift.String)
  case emptyValueFor(key: Swift.String, source: Swift.String)
}
extension SAPFoundation.ConfigurationError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
extension Foundation.Data {
  public init?(base64URLEncoded base64URLString: Swift.String)
  public func base64URLEncodedString() -> Swift.String
}
@_hasMissingDesignatedInitializers final public class SAPFoundationUtils {
  public static func getSDKVersion() -> Swift.String
  @objc deinit
}
@objc public class SAPHTTPCookieStorage : Foundation.HTTPCookieStorage {
  final public let persistentStorage: (any SAPFoundation.CodableStoring)?
  public init(persistentStorage: (any SAPFoundation.CodableStoring)? = nil)
  @objc override dynamic public var cookieAcceptPolicy: Foundation.HTTPCookie.AcceptPolicy {
    @objc get
    @objc set
  }
  @objc override dynamic public var cookies: [Foundation.HTTPCookie]? {
    @objc get
  }
  @objc override dynamic public func cookies(for URL: Foundation.URL) -> [Foundation.HTTPCookie]?
  @objc override dynamic public func sortedCookies(using sortOrder: [Foundation.NSSortDescriptor]) -> [Foundation.HTTPCookie]
  @objc override dynamic public func setCookie(_ cookie: Foundation.HTTPCookie)
  @objc override dynamic public func setCookies(_ cookies: [Foundation.HTTPCookie], for URL: Foundation.URL?, mainDocumentURL: Foundation.URL?)
  @objc override dynamic public func deleteCookie(_ cookie: Foundation.HTTPCookie)
  @objc override dynamic public func removeCookies(since date: Foundation.Date)
  @objc override dynamic public func storeCookies(_ cookies: [Foundation.HTTPCookie], for task: Foundation.URLSessionTask)
  @objc override dynamic public func getCookiesFor(_ task: Foundation.URLSessionTask, completionHandler: @escaping ([Foundation.HTTPCookie]?) -> Swift.Void)
  @objc deinit
}
public protocol DiscoveryServiceConfigurable {
  init(discoveryServiceConfig config: Any) throws
}
public protocol EventObserving : AnyObject {
  func getEventObservingType() -> Swift.String
}
extension SAPFoundation.EventObserving {
  public func getEventObservingType() -> Swift.String
}
open class BasicCredentialStorage : SAPFoundation.BasicCredentialStoring {
  public static let keyPrefix: Swift.String
  open var store: any SAPFoundation.CodableStoring
  open var keyHandler: (Foundation.URL) -> Swift.String
  public init(store: any SAPFoundation.CodableStoring, keyHandler: @escaping (Foundation.URL) -> Swift.String = BasicCredentialStorage.key)
  open func store(credential: SAPFoundation.BasicCredential, for url: Foundation.URL) throws
  public func credential(for url: Foundation.URL) throws -> SAPFoundation.BasicCredential?
  open func delete(for url: Foundation.URL) throws
  public class func key(for url: Foundation.URL) -> Swift.String
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public class SAPcpmsUserIdentityDiscovery : SAPFoundation.UserIdentityObtaining {
  public var oauthToken: Swift.String?
  convenience public init(certificateDiscoveryParameters: SAPFoundation.SAPcpmsUserIdentityConfigurationParameters, oAuth2AuthenticationParameters: SAPFoundation.OAuth2AuthenticationParameters)
  public init(certificateDiscoveryParameters: SAPFoundation.SAPcpmsUserIdentityConfigurationParameters, sapURLSession: SAPFoundation.SAPURLSession)
  public func obtainUserIdentity(completionHandler: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
open class LanguageObserver : SAPFoundation.SAPURLSessionObserving {
  public var language: Swift.String?
  public init(language: Swift.String? = nil)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func copy() -> Any?
  @objc deinit
}
public class WKWebViewPresenter : SAPFoundation.WKWebViewPresenting {
  weak public var delegate: (any SAPFoundation.WebViewPresenterDelegate)?
  weak public var webViewDelegate: (any SAPFoundation.SAPWKNavigationDelegate)?
  public var webViewPresentingViewController: UIKit.UIViewController? {
    get
    set
  }
  public init(delegate: (any SAPFoundation.WebViewPresenterDelegate)? = nil, webViewDelegate: (any SAPFoundation.SAPWKNavigationDelegate)? = nil)
  public func presentWebView(completionHandler: @escaping (WebKit.WKWebView?, (any Swift.Error)?) -> Swift.Void)
  public func dismissWebView()
  @objc deinit
}
public class SAPURLSession {
  public var isValid: Swift.Bool {
    get
  }
  public var delegate: (any SAPFoundation.SAPURLSessionDelegate)? {
    get
  }
  public var delegateQueue: Foundation.OperationQueue {
    get
  }
  public var configuration: Foundation.URLSessionConfiguration {
    get
  }
  public var sessionDescription: Swift.String? {
    get
    set
  }
  public var observers: [any SAPFoundation.SAPURLSessionObserving] {
    get
  }
  public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.default, delegate: (any SAPFoundation.SAPURLSessionDelegate)? = nil, delegateQueue queue: Foundation.OperationQueue? = nil)
  @objc deinit
  public func finishTasksAndInvalidate()
  public func invalidateAndCancel()
  public func reset(completionHandler: @escaping () -> Swift.Void)
  public func flush(completionHandler: @escaping () -> Swift.Void)
  public func copy(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.default, delegate: (any SAPFoundation.SAPURLSessionDelegate)? = nil, delegateQueue queue: Foundation.OperationQueue? = nil) -> SAPFoundation.SAPURLSession
  public func dataTask(with request: Foundation.URLRequest) -> SAPFoundation.SAPURLSessionTask
  public func dataTask(with url: Foundation.URL) -> SAPFoundation.SAPURLSessionTask
  public func uploadTask(with request: Foundation.URLRequest, fromFile fileURL: Foundation.URL) -> SAPFoundation.SAPURLSessionTask
  public func uploadTask(with request: Foundation.URLRequest, from bodyData: Foundation.Data) -> SAPFoundation.SAPURLSessionTask
  public func uploadTask(withStreamedRequest request: Foundation.URLRequest) -> SAPFoundation.SAPURLSessionTask
  public func downloadTask(with request: Foundation.URLRequest) -> SAPFoundation.SAPURLSessionDownloadTask
  public func downloadTask(with url: Foundation.URL) -> SAPFoundation.SAPURLSessionDownloadTask
  public func downloadTask(withResumeData resumeData: Foundation.Data) -> SAPFoundation.SAPURLSessionDownloadTask
  public func dataTask(with request: Foundation.URLRequest, completionHandler: @escaping (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionTask
  public func dataTask(with url: Foundation.URL, completionHandler: @escaping (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionTask
  public func uploadTask(with request: Foundation.URLRequest, fromFile fileURL: Foundation.URL, completionHandler: @escaping (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionTask
  public func uploadTask(with request: Foundation.URLRequest, from bodyData: Foundation.Data, completionHandler: @escaping (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionTask
  public func downloadTask(with request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URL?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionDownloadTask
  public func downloadTask(with url: Foundation.URL, completionHandler: @escaping (Foundation.URL?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionDownloadTask
  public func downloadTask(withResumeData resumeData: Foundation.Data, completionHandler: @escaping (Foundation.URL?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionDownloadTask
  public func uploadTask(withStreamedRequest request: Foundation.URLRequest, needNewBodyStream: @escaping () -> Foundation.InputStream?, completionHandler: @escaping (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionTask
  public func dataTask(with request: Foundation.URLRequest, receivedResponseHandler: ((Foundation.URLResponse) -> Swift.Void)? = nil, receivedDataHandler: @escaping (Foundation.Data) -> Swift.Void, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void) -> SAPFoundation.SAPURLSessionTask
  #if compiler(>=5.3) && $AsyncAwait
  public func data(for request: Foundation.URLRequest) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func data(from url: Foundation.URL) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func upload(for request: Foundation.URLRequest, fromFile fileURL: Foundation.URL) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func upload(for request: Foundation.URLRequest, from bodyData: Foundation.Data) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func download(for request: Foundation.URLRequest) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func download(from url: Foundation.URL) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func download(resumeFrom resumeData: Foundation.Data) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif
  public func register(_ observer: any SAPFoundation.SAPURLSessionObserving)
  public func unregister(_ observer: any SAPFoundation.SAPURLSessionObserving)
  public func isRegistered(_ observer: any SAPFoundation.SAPURLSessionObserving) -> Swift.Bool
  public func configure(_ request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?, (any Swift.Error)?) -> Swift.Void)
  public func configure(_ webView: WebKit.WKWebView, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func configure(_ cookieStore: WebKit.WKHTTPCookieStore, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func configure(_ cookieStore: Foundation.HTTPCookieStorage, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func close(completionHandler: @escaping () -> Swift.Void)
}
extension WebKit.WKWebView {
  @_Concurrency.MainActor(unsafe) public func configure(with urlSession: SAPFoundation.SAPURLSession, completionHandler: @escaping () -> Swift.Void)
}
public protocol OptionalCopying {
  func copy() -> Any?
}
extension SAPFoundation.OptionalCopying {
  public func copy() -> Any?
}
extension SAPFoundation.SAPURLSession {
  @_hasMissingDesignatedInitializers public class DataTaskPublisher : Combine.Publisher {
    public typealias Output = (data: Foundation.Data, response: Foundation.URLResponse)
    public typealias Failure = Swift.Error
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == (data: Foundation.Data, response: Foundation.URLResponse)
    @objc deinit
  }
  public class DataTaskSubscriber : Combine.Subscriber, Combine.Cancellable {
    public typealias Input = (data: Foundation.Data, response: Foundation.URLResponse)
    public typealias Failure = Swift.Error
    public init(sapUrlSession: SAPFoundation.SAPURLSession)
    public func receive(subscription: any Combine.Subscription)
    public func receive(_ input: SAPFoundation.SAPURLSession.DataTaskSubscriber.Input) -> Combine.Subscribers.Demand
    public func receive(completion: Combine.Subscribers.Completion<any Swift.Error>)
    public func cancel()
    @objc deinit
  }
  public func dataTaskPublisher(for urlRequest: Foundation.URLRequest) -> SAPFoundation.SAPURLSession.DataTaskPublisher
  public func dataTaskPublisher(for url: Foundation.URL) -> SAPFoundation.SAPURLSession.DataTaskPublisher
}
@_hasMissingDesignatedInitializers public class OTPAuthenticator : SAPFoundation.AppDelegateObserving {
  public var externalAuthenticatorApplicationID: Swift.String
  convenience public init(otpParameters: SAPFoundation.OTPParameters, webViewPresenter: any SAPFoundation.WKWebViewPresenting)
  convenience public init(settingsParameters: SAPFoundation.SAPcpmsSettingsParameters, webViewPresenter: any SAPFoundation.WKWebViewPresenting)
  public func authenticate(session: SAPFoundation.SAPURLSession, completionHandler: @escaping (_ error: (any Swift.Error)?) -> Swift.Void = OTPAuthenticator.defaultCompletionHandler)
  public func cancelAuthentication()
  public func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  public func validationEndpointURL(from queryItems: [Foundation.URLQueryItem]) -> Foundation.URL?
  public static func defaultCompletionHandler(error: (any Swift.Error)?)
  @objc deinit
}
extension SAPFoundation.OAuth2Authenticator {
  convenience public init(clientCredentialsAuthenticationParameters authenticationParameters: SAPFoundation.OAuth2ClientCredentialsAuthenticationParameters, sapURLSession: SAPFoundation.SAPURLSession = defaultSAPURLSession())
}
public protocol ConnectivityObserver : AnyObject {
  func connectionEstablished()
  func connectionChanged(_ previousReachabilityType: SAPFoundation.ReachabilityType, reachabilityType: SAPFoundation.ReachabilityType)
  func connectionLost()
}
@_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
public class DeviceComplianceChecker {
  public static func isDeviceCompromised() -> Swift.Bool
  @objc deinit
}
public let SAMLAuthenticationParametersAuthorizationEndpointURL: Swift.String
public let SAMLAuthenticationParametersFinishEndpointURL: Swift.String
public struct SAMLAuthenticationParameters {
  public let authorizationEndpointURL: Foundation.URL
  public let finishEndpointURL: Foundation.URL
  public let challengeHeaderName: Swift.String
  public let challengeHeaderValue: Swift.String
  public init(authorizationEndpointURL: Foundation.URL, finishEndpointURL: Foundation.URL, challengeHeaderName: Swift.String = SAMLChallengeHeaderName, challengeHeaderValue: Swift.String = SAMLChallengeHeaderValue)
}
extension SAPFoundation.SAMLAuthenticationParameters {
  public init(settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
}
public let SAMLAuthenticationParametersDiscoveryServiceAuthType: Swift.String
public let SAMLAuthenticationParametersDiscoveryServiceAuthChallengeHeaderName: Swift.String
public let SAMLAuthenticationParametersDiscoveryServiceEndpointURLPath: Swift.String
public let SAMLAuthenticationParametersDiscoveryServiceEndpointRedirectURLParameter: Swift.String
extension SAPFoundation.SAMLAuthenticationParameters : SAPFoundation.DiscoveryServiceConfigurable {
  public init(discoveryServiceConfig config: Any) throws
  public init(backendURL: Foundation.URL, config: Any) throws
}
open class UserIdentityStorage : SAPFoundation.UserIdentityStoring {
  open var store: any SAPFoundation.CodableStoring
  open var keyHandler: (Foundation.URL) -> Swift.String
  public static let keyPrefix: Swift.String
  public init(store: any SAPFoundation.CodableStoring, keyHandler: @escaping (Foundation.URL) -> Swift.String = UserIdentityStorage.key)
  public func store(identity: Foundation.Data, for url: Foundation.URL) throws
  public func identity(for url: Foundation.URL) throws -> Foundation.Data?
  public func delete(for url: Foundation.URL) throws
  public class func key(for url: Foundation.URL) -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SAPURLSessionTask {
  final public let taskID: Foundation.UUID
  public var urlSessionTask: Foundation.URLSessionTask? {
    get
  }
  public var priority: Swift.Float {
    get
    set
  }
  public var taskDescription: Swift.String?
  public var state: Foundation.URLSessionTask.State {
    get
  }
  final public let originalRequest: Foundation.URLRequest?
  public var currentRequest: Foundation.URLRequest? {
    get
  }
  public var response: Foundation.URLResponse? {
    get
  }
  public var context: [Swift.String : Any]
  public func resume()
  public func cancel()
  public func suspend()
  @objc deinit
}
extension SAPFoundation.SAPURLSessionTask {
  public func markBypass(id: Foundation.UUID)
  public func shouldBypass(id: Foundation.UUID) -> Swift.Bool
}
public protocol CompositeCodableStoring : SAPFoundation.CodableStoring {
  var persistentStore: (any SAPCommon.DataStoring)? { get }
  func setPersistentStore(_ store: any SAPCommon.DataStoring) throws
  func releasePersistentStore()
}
open class ConfigurationLoader {
  public var providers: [any SAPFoundation.ConfigurationProviding] {
    get
    set
  }
  weak public var delegate: (any SAPFoundation.ConfigurationLoaderDelegate)?
  public var outputHandler: (any SAPFoundation.ConfigurationPersisting)? {
    get
    set
  }
  public init(delegate: (any SAPFoundation.ConfigurationLoaderDelegate)? = nil, providers: [any SAPFoundation.ConfigurationProviding]? = nil, outputHandler: (any SAPFoundation.ConfigurationPersisting)? = nil)
  open func resetStoredData()
  @discardableResult
  open func loadConfiguration(userInputs: [Swift.String : [Swift.String : Any]] = [:]) -> Swift.Bool
  @discardableResult
  open func constructDefaultConfigurationProviderQueue() -> Swift.Int
  @objc deinit
}
open class CSRFTokenStorage : SAPFoundation.CSRFTokenStoring {
  open var store: any SAPFoundation.CodableStoring
  public init(store: any SAPFoundation.CodableStoring)
  public func store(token: Swift.String, for url: Foundation.URL) throws
  public func token(for url: Foundation.URL) throws -> Swift.String?
  public func deleteToken(for url: Foundation.URL) throws
  @objc deinit
}
extension Foundation.OperatingSystemVersion : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct SAPcpmsRemoteNotificationParameters {
  public struct Capability {
    public let category: Swift.String
    public let name: Swift.String
    public let value: Swift.String
    public init(category: Swift.String, name: Swift.String, value: Swift.String)
  }
  public let deviceType: Swift.String
  public let pushGroup: Swift.String
  public let userLocale: Swift.String
  public let timeZone: Swift.String
  public let formFactor: Swift.String
  public let capabilities: [SAPFoundation.SAPcpmsRemoteNotificationParameters.Capability]
  public static let deviceModel: Swift.String
  public static let deviceLanguageCode: Swift.String
  public static let deviceTimeZone: Swift.String
  public init(deviceType: Swift.String = deviceModel, pushGroup: Swift.String = "", userLocale: Swift.String = deviceLanguageCode, timeZone: Swift.String = deviceTimeZone, formFactor: Swift.String = "", capabilities: [SAPFoundation.SAPcpmsRemoteNotificationParameters.Capability] = [])
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var modelName: Swift.String {
    get
  }
  @_Concurrency.MainActor(unsafe) public var deviceIdentifier: Swift.String {
    get
  }
  @_Concurrency.MainActor(unsafe) public var environment: Swift.String {
    get
  }
}
public enum OpenURLPolicy : Swift.String {
  case blocked
  case unrestricted
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class DefaultBasicCredentialDiscovery : SAPFoundation.BasicCredentialDiscovery {
  public init()
  public var presentingViewController: UIKit.UIViewController? {
    get
    set
  }
  public func provideBasicCredential(for url: Foundation.URL, challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (SAPFoundation.BasicCredential?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
public class PKCS12UserIdentityDiscovery : SAPFoundation.UserIdentityObtaining {
  convenience public init(resourceInBundle: Swift.String, resourceType: Swift.String, passphrase: Swift.String, bundle: Foundation.Bundle = Bundle.main) throws
  convenience public init(path: Swift.String, passphrase: Swift.String) throws
  convenience public init(fileURL: Foundation.URL, passphrase: Swift.String) throws
  public init(data: Foundation.Data, passphrase: Swift.String)
  public func obtainUserIdentity(completionHandler: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
public struct SAPcpmsUserIdentityConfigurationParameters {
  public let attributesEndpoint: Foundation.URL
  public let requestEndpoint: Foundation.URL
  public let retireEndpoint: Foundation.URL
  public let publicKeyPinSet: [Swift.String]
  public init(attributesEndpoint: Foundation.URL, requestEndpoint: Foundation.URL, retireEndpoint: Foundation.URL, publicKeyPinSet: [Swift.String])
}
extension SAPFoundation.SAPcpmsUserIdentityConfigurationParameters {
  public init?(certificateDiscoveryConfiguration configuration: [Swift.String : Any])
}
extension SAPFoundation.OAuth2AuthenticationParameters {
  public init?(certificateDiscoveryAuthenticationConfiguration configuration: [Swift.String : Any])
  public init?(certificateDiscoveryConfiguration configuration: [Swift.String : Any])
}
public protocol AuxiliaryKeyContainerRepresenting : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  associatedtype AuxKeyType : Swift.Decodable, Swift.Encodable, Swift.Hashable
  func get() -> Self.AuxKeyType
}
public struct SLSLoginInputField {
  public enum InputType {
    case plain
    case secure
    public static func == (a: SAPFoundation.SLSLoginInputField.InputType, b: SAPFoundation.SLSLoginInputField.InputType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let fieldName: Swift.String
  public let preset: Swift.String
  public let prompt: Swift.String
  public let type: SAPFoundation.SLSLoginInputField.InputType
  public let confirmField: Swift.String
  public init(fieldName: Swift.String = "", preset: Swift.String = "", prompt: Swift.String = "", type: SAPFoundation.SLSLoginInputField.InputType = InputType.plain, confirmField: Swift.String = "")
}
public struct OAuth2ServerError {
  public let responseData: Foundation.Data?
  public let code: Swift.String?
  public let message: Swift.String?
  public let uri: Swift.String?
  public let state: Swift.String?
  public init(code: Swift.String, message: Swift.String?, uri: Swift.String?, state: Swift.String?)
  public init(data: Foundation.Data)
}
extension SAPFoundation.OAuth2ServerError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public enum ApplicationVersioningError : Swift.Error {
  case inactive
  public static func == (a: SAPFoundation.ApplicationVersioningError, b: SAPFoundation.ApplicationVersioningError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.ApplicationVersioningError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
open class ApplicationVersionObserver : SAPFoundation.SAPURLSessionObserving {
  public init()
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  @objc deinit
}
public protocol AuxiliaryCommunicationProviding {
  var context: [Swift.String : Any] { get set }
}
@_hasMissingDesignatedInitializers public class AppDelegateDispatcher : SAPFoundation.EventDispatching {
  public static func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any] = [:]) -> Swift.Bool
  public static func application(_ application: UIKit.UIApplication, continue userActivity: Foundation.NSUserActivity, restorationHandler: @escaping ([any UIKit.UIUserActivityRestoring]?) -> Swift.Void) -> Swift.Bool
  public static func application(_ application: UIKit.UIApplication, handleEventsForBackgroundURLSession identifier: Swift.String, completionHandler: @escaping () -> Swift.Void)
  public static func register(_ observer: any SAPFoundation.AppDelegateObserving)
  public static func unregister(_ observer: any SAPFoundation.AppDelegateObserving)
  public func registerObserver(_ observer: any SAPFoundation.EventObserving)
  public func unregisterObserver(_ observer: any SAPFoundation.EventObserving)
  @objc deinit
}
public enum APIKeyAuthenticationError : Swift.Error {
  case invalidArgument(detail: Swift.String)
  case http(error: any Swift.Error, statusCode: Swift.Int?, response: Swift.String?)
  case missingHTTPResponse
  case authenticationInProgress
  case missingAPIKeyCredential
  case unauthorized
  case invalidAPIKeyCredential
  case missingAPIKeyConfig
  case generic(statusCode: Swift.Int?)
  case cancelled
}
extension SAPFoundation.APIKeyAuthenticationError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public struct SAPcpmsNetworkSynchronizationPolicyOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let wifi: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public static let mobileNetwork: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public static let roaming: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public static let `default`: SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public typealias ArrayLiteralElement = SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public typealias Element = SAPFoundation.SAPcpmsNetworkSynchronizationPolicyOptions
  public typealias RawValue = Swift.Int
}
public enum SAPcpmsSettingsError : Swift.Error {
  case malformed(type: SAPFoundation.SAPcpmsSettingsError.MalformedType, description: Swift.String)
  case network
  case invalidHTTPStatus(statusCode: Swift.Int)
  case missingValueForSettingsTarget
  public enum MalformedType {
    case missingKey
    case invalidType
    public static func == (a: SAPFoundation.SAPcpmsSettingsError.MalformedType, b: SAPFoundation.SAPcpmsSettingsError.MalformedType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SAPFoundation.SAPcpmsSettingsError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public protocol WebViewPresenterDelegate : AnyObject {
  func didReloadWebView()
  func didDismissWebView()
}
public protocol SAPWKNavigationDelegate : AnyObject {
  func webView(_ webView: WebKit.WKWebView, handleFailedProvisionalNavigation navigation: WebKit.WKNavigation!, withError error: any Swift.Error) -> (any Swift.Error)?
  func webView(_ webView: WebKit.WKWebView, handleFailed navigation: WebKit.WKNavigation!, withError error: any Swift.Error) -> (any Swift.Error)?
}
public protocol SAPWKUIDelegate : AnyObject {
  func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
  func webView(_ webView: WebKit.WKWebView, runJavaScriptAlertPanelWithMessage message: Swift.String, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping () -> Swift.Void)
  func webView(_ webView: WebKit.WKWebView, runJavaScriptConfirmPanelWithMessage message: Swift.String, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping (Swift.Bool) -> Swift.Void)
  func webView(_ webView: WebKit.WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: Swift.String, defaultText: Swift.String?, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping (Swift.String?) -> Swift.Void)
}
public protocol WKWebViewPresenting : AnyObject {
  var delegate: (any SAPFoundation.WebViewPresenterDelegate)? { get set }
  var webViewDelegate: (any SAPFoundation.SAPWKNavigationDelegate)? { get set }
  var webViewUIDelegate: (any SAPFoundation.SAPWKUIDelegate)? { get set }
  func presentWebView(completionHandler: @escaping (WebKit.WKWebView?, (any Swift.Error)?) -> Swift.Void)
  func dismissWebView()
  func reloadWebView()
}
public protocol SFSafariViewControllerPresenting : AnyObject {
  var delegate: (any SAPFoundation.WebViewPresenterDelegate)? { get set }
  func presentWebView(with url: Foundation.URL, completionHandler: @escaping (SafariServices.SFSafariViewController?, (any Swift.Error)?) -> Swift.Void)
  func dismissWebView()
}
@available(iOS 12.0, *)
public protocol ASWebAuthenticationSessionPresenting : AnyObject {
  var delegate: (any SAPFoundation.WebViewPresenterDelegate)? { get set }
  func presentWebView(with url: Foundation.URL, sessionCompletionHandler: @escaping AuthenticationServices.ASWebAuthenticationSession.CompletionHandler, completionHandler: @escaping (AuthenticationServices.ASWebAuthenticationSession?, (any Swift.Error)?) -> Swift.Void)
  func dismissWebView()
  func reloadWebView()
}
extension SAPFoundation.SAPWKNavigationDelegate {
  public func webView(_ webView: WebKit.WKWebView, handleFailedProvisionalNavigation navigation: WebKit.WKNavigation!, withError error: any Swift.Error) -> (any Swift.Error)?
  public func webView(_ webView: WebKit.WKWebView, handleFailed navigation: WebKit.WKNavigation!, withError error: any Swift.Error) -> (any Swift.Error)?
}
extension SAPFoundation.SAPWKUIDelegate {
  public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
  public func webView(_ webView: WebKit.WKWebView, runJavaScriptAlertPanelWithMessage message: Swift.String, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping () -> Swift.Void)
  public func webView(_ webView: WebKit.WKWebView, runJavaScriptConfirmPanelWithMessage message: Swift.String, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping (Swift.Bool) -> Swift.Void)
  public func webView(_ webView: WebKit.WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: Swift.String, defaultText: Swift.String?, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping (Swift.String?) -> Swift.Void)
}
extension SAPFoundation.WKWebViewPresenting {
  public var webViewDelegate: (any SAPFoundation.SAPWKNavigationDelegate)? {
    get
    set
  }
  public var webViewUIDelegate: (any SAPFoundation.SAPWKUIDelegate)? {
    get
    set
  }
  public func reloadWebView()
}
extension SAPFoundation.WebViewPresenterDelegate {
  public func didReloadWebView()
}
extension SAPFoundation.ASWebAuthenticationSessionPresenting {
  public func reloadWebView()
}
public protocol AuthenticationDelegate : AnyObject {
  func authenticationHandler(_ handler: any SAPFoundation.AuthenticationHandling, user: Swift.String, didChange to: Swift.String)
  func authenticationHandler(_ handler: any SAPFoundation.AuthenticationHandling, user: Swift.String?, didFailToAuthenticate error: any Swift.Error)
  func authenticationHandler(_ handler: any SAPFoundation.AuthenticationHandling, didAuthenticate userInfo: SAPFoundation.SAPcpmsUserRoles.SAPcpmsUserInfo, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
}
extension SAPFoundation.AuthenticationDelegate {
  public func authenticationHandler(_: any SAPFoundation.AuthenticationHandling, didAuthenticate userInfo: SAPFoundation.SAPcpmsUserRoles.SAPcpmsUserInfo, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
}
public protocol SAPPassportManaging {
  func getPassport() throws -> SAPFoundation.Passport
  func setPassport(_ passport: SAPFoundation.Passport)
  func clearPassport()
}
public class SAPcpmsRemoteNotificationClient {
  public init(sapURLSession: SAPFoundation.SAPURLSession, destinationURL: Foundation.URL, feedbackURL: Foundation.URL? = nil)
  convenience public init(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  public func registerDeviceToken(_ deviceToken: Foundation.Data, withParameters parameters: SAPFoundation.SAPcpmsRemoteNotificationParameters? = nil, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func unregisterDeviceToken(completionHandler: @escaping (_ error: (any Swift.Error)?) -> Swift.Void = SAPcpmsRemoteNotificationClient.defaultCompletionHandler)
  @available(*, deprecated, renamed: "unregisterDeviceToken")
  public func deregisterDeviceToken(completionHandler: @escaping (_ error: (any Swift.Error)?) -> Swift.Void = SAPcpmsRemoteNotificationClient.defaultCompletionHandler)
  public func updateNotificationStatus(userInfo: [Swift.AnyHashable : Any], completionHandler: @escaping (_ error: (any Swift.Error)?) -> Swift.Void = SAPcpmsRemoteNotificationClient.defaultCompletionHandler)
  public static func defaultCompletionHandler(_ error: (any Swift.Error)?)
  #if compiler(>=5.3) && $AsyncAwait
  public func getAllSubscribedTopics() async throws -> [Swift.String]
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func subscribe(to topic: Swift.String) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func unsubscribe(from topic: Swift.String) async throws
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IdentityHelper {
  public static var shared: SAPFoundation.IdentityHelper {
    get
  }
  public static let passphrase: Swift.String
  public func pkcs12Data(fromIdentity identity: Security.SecIdentity, passphrase: Swift.String = passphrase) throws -> Foundation.Data
  public func identity(fromPKCS12Data pkcs12Data: Foundation.Data, passphrase: Swift.String = passphrase) throws -> (identity: Security.SecIdentity, certificates: [Security.SecCertificate]?)
  public func urlCredentialFromIdentity(identityData: Foundation.Data, passphrase: Swift.String = passphrase) throws -> Foundation.URLCredential
  @objc deinit
}
extension UIKit.UIApplication {
  @_Concurrency.MainActor(unsafe) public static var sharedOrNil: UIKit.UIApplication? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func appExtensionSafeOpen(_ url: Foundation.URL, options: [UIKit.UIApplication.OpenExternalURLOptionsKey : Any] = [:], completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
public enum SAMLError : Swift.Error {
  case webView(error: any Swift.Error)
  case invalidArgument(detail: Swift.String)
  case authenticationInProgress
  case credentialsRejected
  case backgroundAuthentication
  case cancelled
  case webViewReloaded
}
extension SAPFoundation.SAMLError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public enum SAPURLSessionError : Swift.Error {
  case invalidRequest
  case unexpectedHTTPMethod
  case invalidURLSession
  case failedToRetriveCSRFToken(Swift.String?)
}
extension SAPFoundation.SAPURLSessionError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
open class CodableCache<Cache> : SAPFoundation.CodableCaching where Cache : SAPFoundation.Caching, Cache.ValueType == Foundation.NSData {
  public typealias KeyType = Cache.KeyType
  open var costOfEntries: Swift.Double {
    get
  }
  open var numberOfEntries: Swift.Int {
    get
  }
  public init(cache: Cache, coder: any SAPFoundation.CoderProtocol = PlistCoder())
  public func get<T>(_ type: T.Type, for key: SAPFoundation.CodableCache<Cache>.KeyType) throws -> T? where T : Swift.Decodable, T : Swift.Encodable
  public func put<T>(_ value: T, for key: SAPFoundation.CodableCache<Cache>.KeyType, with cost: Swift.Double = 0) throws where T : Swift.Decodable, T : Swift.Encodable
  public func entry<T>(_ type: T.Type, for key: SAPFoundation.CodableCache<Cache>.KeyType) throws -> SAPFoundation.CacheEntry<T>? where T : Swift.Decodable, T : Swift.Encodable
  public func remove(for key: SAPFoundation.CodableCache<Cache>.KeyType)
  public func removeAllValues()
  public func keys() -> Swift.AnySequence<SAPFoundation.CodableCache<Cache>.KeyType>
  @objc deinit
}
public struct ConnectivityUtils {
  public static func isMobileConnected() -> Swift.Bool
  public static func isWiFiConnected() -> Swift.Bool
  public static func isConnected() -> Swift.Bool
  public static func isConnected(_ reachabilityType: SAPFoundation.ReachabilityType) -> Swift.Bool
}
public enum UserIdentityObserverError : Swift.Error {
  case invalidUserIdentity
  case cancelled
  public static func == (a: SAPFoundation.UserIdentityObserverError, b: SAPFoundation.UserIdentityObserverError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.UserIdentityObserverError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public protocol OAuth2Authentication {
  func authenticate(completionHandler: @escaping (SAPFoundation.OAuth2Token?, (any Swift.Error)?) -> Swift.Void)
  func refresh(token: SAPFoundation.OAuth2Token, completionHandler: @escaping (SAPFoundation.OAuth2Token?, (any Swift.Error)?) -> Swift.Void)
  func cancelAuthentication()
}
public protocol AuxiliaryDataServiceProviding {
  associatedtype CommunicationProvider : SAPFoundation.AuxiliaryCommunicationProviding
  associatedtype DataContainer : SAPFoundation.AuxiliaryDataContainerRepresenting
  associatedtype KeyContainer : SAPFoundation.AuxiliaryKeyContainerRepresenting
  associatedtype DataRequest : SAPFoundation.AuxiliaryDataRequestRepresenting
  func configure(provider: Self.CommunicationProvider)
  func get(auxKeyContainer: Self.KeyContainer) throws -> Self.DataContainer
  func put(auxDataContainer: Self.DataContainer, for key: Self.KeyContainer) throws
  func delete(for auxKeyRepresenter: Self.KeyContainer) throws
}
open class APIKeyAuthenticationObserver {
  public init(apikeyCredentialDiscovery: any SAPFoundation.APIKeyCredentialDiscovery = DefaultAPIKeyCredentialDiscovery(), isAPIKeyAccessOnly: Swift.Bool = false)
  open func isChallenge(dataTask: SAPFoundation.SAPURLSessionTask, response: Foundation.URLResponse) -> Swift.Bool
  @objc deinit
}
extension SAPFoundation.APIKeyAuthenticationObserver : SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.HTTPRedirectDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func copy() -> Any?
}
public enum ReachabilityType : Swift.CustomStringConvertible {
  case wwan
  case wifi
  case offline
  public var description: Swift.String {
    get
  }
  public static func == (a: SAPFoundation.ReachabilityType, b: SAPFoundation.ReachabilityType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SLSLoginInput {
  public let clientMessage: Swift.String
  public let disclaimer: Swift.String
  public let messageType: SAPFoundation.SLSLoginInput.ClientMessageType
  public let inputFields: [SAPFoundation.SLSLoginInputField]
  public enum ClientMessageType : Swift.Int {
    case ok
    case warning
    case error
    case none
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public init(clientMessage: Swift.String = "", disclaimer: Swift.String = "", messageType: SAPFoundation.SLSLoginInput.ClientMessageType = SLSLoginInput.ClientMessageType.none, inputFields: [SAPFoundation.SLSLoginInputField])
}
public protocol UserIdentityStoring : AnyObject {
  func store(identity: Foundation.Data, for: Foundation.URL) throws
  func identity(for: Foundation.URL) throws -> Foundation.Data?
  func delete(for: Foundation.URL) throws
}
open class CorrelationObserver : SAPFoundation.SAPURLSessionObserving {
  public init()
  open func newCorrelationID() -> Swift.String
  open func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func copy() -> Any?
  @objc deinit
}
public class AuxiliarySecurityManager {
  public init(auxiliaryDataStore: any SAPCommon.DataStoring, sharedDataStore: (any SAPCommon.DataStoring)?)
  convenience public init(auxiliaryStoreName: Swift.String, auxiliaryAccessGroup: Swift.String, sharedStoreName: Swift.String, sharedAccesGroup: Swift.String) throws
  public func getESPAKAuxiliary(obfuscatedAuxiliaryKey: [Swift.UInt8]) throws -> Foundation.Data
  public func getAuxiliaryDataEncryptionKey() throws -> Foundation.Data
  @objc deinit
}
public class SecurityManager {
  public var auxDataEncryptionKeyStoreName: Swift.String
  public var auxDataEncryptionKeyStoreAccessGroup: Swift.String
  public init(primaryDataStore: any SAPCommon.DataStoring, sharedDataStore: (any SAPCommon.DataStoring)?, secretSharing: any SAPCommon.SecretSharing = KNThresholdSchemeFacilitator())
  public init(primaryDataStore: any SAPCommon.DataStoring)
  convenience public init(primaryStoreName: Swift.String, primaryAccessGroup: Swift.String, sharedStoreName: Swift.String, sharedAccesGroup: Swift.String) throws
  public init(sharedDataStore: any SAPCommon.DataStoring)
  public init()
  public func generateDataEncryptionKey(passcode: Swift.String, saltKeyName: Swift.String, obfuscatedPrimaryKey: [Swift.UInt8]?, session: SAPFoundation.SAPURLSession?) throws -> Foundation.Data
  public func generateAuxiliaryDataEncryptionKey() throws
  public func getAuxiliaryDataEncryptionKey() throws -> Foundation.Data
  public func getDataEncryptionKeyUsingPasscode(passcode: Swift.String, saltKeyName: Swift.String) throws -> Foundation.Data
  public func getDataEncryptionKeyUsingSymmetricPairedAccessKey(eSPAKAuxiliary: Foundation.Data, obfuscatedPrimaryKey: [Swift.UInt8], session: SAPFoundation.SAPURLSession?, completionHandler: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
public protocol SAPURLSessionObserving : AnyObject, SAPFoundation.OptionalCopying {
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, didBecomeInvalidWithError error: (any Swift.Error)?, completionHandler: @escaping () -> Swift.Void)
  func sapURLSessionDidFinishEvents(forBackgroundURLSession session: SAPFoundation.SAPURLSession, completionHandler: @escaping () -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willBeginDelayedRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.DelayedRequestDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, taskIsWaitingForConnectivity task: SAPFoundation.SAPURLSessionTask)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.HTTPRedirectDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (SAPFoundation.SAPURLSession.AuthChallengeDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willUse credential: Foundation.URLCredential, for challenge: Foundation.URLAuthenticationChallenge)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, needNewBodyStream completionHandler: @escaping (SAPFoundation.SAPURLSession.InputStreamDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64, completionHandler: @escaping (SAPFoundation.SAPURLSession.CancellableDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics, completionHandler: @escaping () -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didBecome downloadTask: Foundation.URLSessionDownloadTask, completionHandler: @escaping (SAPFoundation.SAPURLSession.CancellableDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive data: Foundation.Data, completionHandler: @escaping (SAPFoundation.SAPURLSession.DataDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.CacheResponseDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64, completionHandler: @escaping (SAPFoundation.SAPURLSession.CancellableDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64, completionHandler: @escaping (SAPFoundation.SAPURLSession.CancellableDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCreate sessionTask: Foundation.URLSessionTask)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, didCreate task: SAPFoundation.SAPURLSessionTask, for sessionTask: Foundation.URLSessionTask)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
}
extension SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, didBecomeInvalidWithError error: (any Swift.Error)?, completionHandler: @escaping () -> Swift.Void)
  public func sapURLSessionDidFinishEvents(forBackgroundURLSession session: SAPFoundation.SAPURLSession, completionHandler: @escaping () -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willBeginDelayedRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.DelayedRequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, taskIsWaitingForConnectivity task: SAPFoundation.SAPURLSessionTask)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.HTTPRedirectDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (SAPFoundation.SAPURLSession.AuthChallengeDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willUse credential: Foundation.URLCredential, for challenge: Foundation.URLAuthenticationChallenge)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, needNewBodyStream completionHandler: @escaping (SAPFoundation.SAPURLSession.InputStreamDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64, completionHandler: @escaping (SAPFoundation.SAPURLSession.CancellableDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics, completionHandler: @escaping () -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didBecome downloadTask: Foundation.URLSessionDownloadTask, completionHandler: @escaping (SAPFoundation.SAPURLSession.CancellableDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive data: Foundation.Data, completionHandler: @escaping (SAPFoundation.SAPURLSession.DataDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.CacheResponseDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64, completionHandler: @escaping (SAPFoundation.SAPURLSession.CancellableDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64, completionHandler: @escaping (SAPFoundation.SAPURLSession.CancellableDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCreate sessionTask: Foundation.URLSessionTask)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, didCreate task: SAPFoundation.SAPURLSessionTask, for sessionTask: Foundation.URLSessionTask)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func copy() -> Any?
}
open class CompositeStorage : SAPFoundation.CompositeCodableStoring {
  public var persistentStore: (any SAPCommon.DataStoring)? {
    get
  }
  public init(memoryStore: any SAPCommon.DataStoring = MemoryDataStorage(), coder: any SAPFoundation.CoderProtocol = PlistCoder())
  open func get<T>(_ type: T.Type, for key: Swift.String) throws -> T? where T : Swift.Decodable, T : Swift.Encodable
  open func put<T>(_ value: T, for key: Swift.String) throws where T : Swift.Decodable, T : Swift.Encodable
  open func remove(for key: Swift.String) throws
  open func keys() throws -> Swift.Set<Swift.String>
  open func setPersistentStore(_ store: any SAPCommon.DataStoring) throws
  open func releasePersistentStore()
  @objc deinit
}
public protocol SAMLAuthentication {
  func authenticate(session: SAPFoundation.SAPURLSession, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  func authenticate(cookies: [Foundation.HTTPCookie], completionHandler: @escaping ([Foundation.HTTPCookie]?, (any Swift.Error)?) -> Swift.Void)
  func cancelAuthentication()
}
extension SAPFoundation.SAMLAuthentication {
  public func authenticate(session: SAPFoundation.SAPURLSession, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func authenticate(cookies: [Foundation.HTTPCookie], completionHandler: @escaping ([Foundation.HTTPCookie]?, (any Swift.Error)?) -> Swift.Void)
}
extension SAPCommon.Logger {
  public func apply(sapcpmsLogSettings: SAPCommon.SAPcpmsLogSettings)
}
extension SAPCommon.SAPcpmsLogSettings {
  public init?(sapcpmsSettings: Any) throws
  public init?(sapcpmsLogSettings: Any) throws
}
public enum SAPcpmsLogUploaderError : Swift.Error {
  case missingLogFiles
  case emptyLogFiles
  case networkError(error: (any Swift.Error)?, httpStatuscode: Swift.Int?, response: Swift.String?)
  case uploadAlreadyInProgress
  case couldNotDeleteLogs
  case internalError(error: (any Swift.Error)?)
  case configurationNotEnabled
}
extension SAPFoundation.SAPcpmsLogUploaderError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public class AuxiliaryDataContainer<T> : SAPFoundation.AuxiliaryDataContainerRepresenting, Swift.Codable where T : Swift.Decodable, T : Swift.Encodable {
  public typealias AuxDataType = T
  public init(data: T)
  public var creationTime: Foundation.Date {
    get
    set
  }
  public var lastModified: Foundation.Date {
    get
    set
  }
  public func get() -> T
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public enum OTPError : Swift.Error {
  case webView(error: any Swift.Error)
  case authenticationInProgress
  case credentialsRejected
  case backgroundAuthentication
  case cancelled
}
extension SAPFoundation.OTPError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
public protocol DigitallySignedMessage {
  var payload: Foundation.Data { get }
  var signature: Foundation.Data { get }
  var algorithm: SAPFoundation.DigitalSignatureAlgorithm { get }
}
public protocol DigitallySignedMessageParser {
  associatedtype Input
  static func parse(_ input: Self.Input) throws -> any SAPFoundation.DigitallySignedMessage
}
public enum SecurityManagerError : Swift.Error {
  case failedToReadDataEncryptionKey
  case failedToReadAuxDataEncryptionKey
  case failedToReadDataEncryptionKeyUsingPasscode
  case failedToEncryptDEKUsingPBKDF
  case failedToGetDEKUsingSPAK
  case failedToUpdateESPAKAuxiliary
  case failedToReadEESPAKAuxiliaryFromDataStore
  case failedToReadESPAKPrimary
  case failedToDecryptESPAKPrimaryWithSPK
  case failedToDecryptESPAKAuxiliaryWithSPAKPrimary
  case failedToSplitSecret
  case failedToCombineSecret
  public static func == (a: SAPFoundation.SecurityManagerError, b: SAPFoundation.SecurityManagerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SAPFoundation.SecurityManagerError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class FeedbackUploader {
  public static func upload(feedbacks: [SAPCommon.Feedback], sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters, anonymous: Swift.Bool = true, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void = FeedbackUploader.defaultCompletionHandler)
  public static func upload(to uploadEndpoint: Foundation.URL, feedbacks: [SAPCommon.Feedback], sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters, anonymous: Swift.Bool = true, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  public static func defaultCompletionHandler(_ error: (any Swift.Error)?)
  public enum FeedbackUploadError : SAPCommon.SAPError {
    case network(any Swift.Error)
    case invalidResponse(Foundation.Data?, Foundation.URLResponse?)
    case reportGenerationFailed
    public var description: Swift.String {
      get
    }
    public var errorDescription: Swift.String? {
      get
    }
    public var debugDescription: Swift.String {
      get
    }
  }
  @objc deinit
}
public enum URLConfigurationProviderError : Swift.Error {
  case invalid(detail: Swift.String)
  case missing(argument: Swift.String)
  case missingConfiguration
}
extension SAPFoundation.URLConfigurationProviderError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
}
open class URLConfigurationProvider : SAPFoundation.ConfigurationProviding, SAPFoundation.AppDelegateObserving {
  public static let hostParameterName: Swift.String
  public static let portParameterName: Swift.String
  public static let protocolParameterName: Swift.String
  public static let authTypeParameterName: Swift.String
  public static let tokenEndpointParameterName: Swift.String
  public static let authorizationEndpointParameterName: Swift.String
  public static let oauthEndUserUIParameterName: Swift.String
  public static let oauthClientIDParameterName: Swift.String
  public static let oauthRedirectURLParameterName: Swift.String
  public static let oauthGrantTypeParameterName: Swift.String
  public static let oauthPasscodeParameterName: Swift.String
  public static let authChallengeHeaderParameterName: Swift.String
  public static let endpointUriParameterName: Swift.String
  public static let redirectParamParameterName: Swift.String
  public var providerIdentifier: Swift.String
  public var expectedInput: [Swift.String : Any]
  final public let defaultTimeout: Swift.Double
  public init(defaultTimeout: Swift.Double = 1)
  @objc deinit
  public func provideConfiguration(input: [Swift.String : Any]) -> (providerSuccess: Swift.Bool, configuration: Foundation.NSDictionary, returnError: (any Swift.Error)?)
  public func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  public func application(_ application: UIKit.UIApplication, continue userActivity: Foundation.NSUserActivity, restorationHandler: @escaping ([any UIKit.UIUserActivityRestoring]?) -> Swift.Void) -> Swift.Bool
  open func isConfigurationURL(_ url: Foundation.URL) -> Swift.Bool
}
extension SAPFoundation.URLConfigurationProvider : SAPFoundation.SceneDelegateObserving {
  public func scene(_ scene: UIKit.UIScene, openURLContexts URLContexts: Swift.Set<UIKit.UIOpenURLContext>)
  public func scene(_ scene: UIKit.UIScene, willConnectTo session: UIKit.UISceneSession, options connectionOptions: UIKit.UIScene.ConnectionOptions)
  public func scene(_ scene: UIKit.UIScene, continue userActivity: Foundation.NSUserActivity)
}
public protocol SAPURLSessionDelegate : AnyObject {
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  func sapURLSessionDidFinishEvents(forBackgroundURLSession session: SAPFoundation.SAPURLSession)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willBeginDelayedRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.DelayedRequestDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, taskIsWaitingForConnectivity task: SAPFoundation.SAPURLSessionTask)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.HTTPRedirectDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (SAPFoundation.SAPURLSession.AuthChallengeDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, needNewBodyStream completionHandler: @escaping (SAPFoundation.SAPURLSession.InputStreamDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didBecome downloadTask: Foundation.URLSessionDownloadTask)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive data: Foundation.Data)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.CacheResponseDisposition) -> Swift.Void)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCreate sessionTask: Foundation.URLSessionTask)
  func sapURLSession(_ session: SAPFoundation.SAPURLSession, didCreate task: SAPFoundation.SAPURLSessionTask, for sessionTask: Foundation.URLSessionTask)
}
extension SAPFoundation.SAPURLSessionDelegate {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  public func sapURLSessionDidFinishEvents(forBackgroundURLSession session: SAPFoundation.SAPURLSession)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willBeginDelayedRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.DelayedRequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, taskIsWaitingForConnectivity task: SAPFoundation.SAPURLSessionTask)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.HTTPRedirectDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (SAPFoundation.SAPURLSession.AuthChallengeDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, needNewBodyStream completionHandler: @escaping (SAPFoundation.SAPURLSession.InputStreamDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didBecome downloadTask: Foundation.URLSessionDownloadTask)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive data: Foundation.Data)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.CacheResponseDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCreate sessionTask: Foundation.URLSessionTask)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, didCreate task: SAPFoundation.SAPURLSessionTask, for sessionTask: Foundation.URLSessionTask)
}
public struct SLSConfigurationParameters {
  public let subjectName: Swift.String
  public let subjectAltNamesRfc822: Swift.String
  public let subjectAltNamesDNS: Swift.String
  public let loginURL: Foundation.URL
  public let certificateURL: Foundation.URL
  public init(loginURL: Foundation.URL, certificateURL: Foundation.URL, subjectName: Swift.String = "", subjectAltNamesRfc822: Swift.String = "", subjectAltNamesDNS: Swift.String = "")
  public init?(slsServerURL: Foundation.URL, profile: Swift.String, subjectName: Swift.String = "", subjectAltNamesRfc822: Swift.String = "", subjectAltNamesDNS: Swift.String = "")
  public init?(baseURL: Foundation.URL, applicationID: Swift.String, subjectName: Swift.String = "", subjectAltNamesRfc822: Swift.String = "", subjectAltNamesDNS: Swift.String = "")
  public init?(settingsParameters: SAPFoundation.SAPcpmsSettingsParameters, subjectName: Swift.String = "", subjectAltNamesRfc822: Swift.String = "", subjectAltNamesDNS: Swift.String = "")
}
public let SLSConfigurationParametersServerURL: Swift.String
public let SLSConfigurationParametersProfile: Swift.String
public let SLSConfigurationParametersSubjectName: Swift.String
public let SLSConfigurationParametersSubjectAltNamesRFC822: Swift.String
public let SLSConfigurationParametersSubjectAltNamesDNS: Swift.String
extension SAPFoundation.SLSConfigurationParameters : SAPFoundation.DiscoveryServiceConfigurable {
  public init(discoveryServiceConfig config: Any) throws
}
@objc @_inheritsConvenienceInitializers @available(*, deprecated, message: "Please use your own UI delegate implementation")
public class DefaultSAPWKUIDelegate : ObjectiveC.NSObject, WebKit.WKUIDelegate {
  @objc public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
  @objc override dynamic public init()
  @objc deinit
}
public let SAMLChallengeHeaderName: Swift.String
public let SAMLChallengeHeaderValue: Swift.String
open class SAMLObserver {
  final public let challengeHeaderName: Swift.String
  final public let challengeHeaderValue: Swift.String
  public var authenticationHandler: (any SAPFoundation.AuthenticationHandling)?
  public init(authenticator: any SAPFoundation.SAMLAuthentication, challengeHeaderName: Swift.String = SAMLChallengeHeaderName, challengeHeaderValue: Swift.String = SAMLChallengeHeaderValue)
  convenience public init(authenticationParameters: SAPFoundation.SAMLAuthenticationParameters)
  convenience public init(settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  open func isChallenge(dataTask: SAPFoundation.SAPURLSessionTask, response: Foundation.URLResponse) -> Swift.Bool
  @objc deinit
}
extension SAPFoundation.SAMLObserver : SAPFoundation.SAPURLSessionObserving {
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, willSend request: Foundation.URLRequest, completionHandler: @escaping (SAPFoundation.SAPURLSession.RequestDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, dataTask: SAPFoundation.SAPURLSessionTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (SAPFoundation.SAPURLSession.ResponseDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, downloadTask: SAPFoundation.SAPURLSessionTask, didFinishDownloadingTo location: Foundation.URL, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?, completionHandler: @escaping (SAPFoundation.SAPURLSession.DidCompleteDisposition) -> Swift.Void)
  public func sapURLSession(_ session: SAPFoundation.SAPURLSession, task: SAPFoundation.SAPURLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func copy() -> Any?
}
public enum DigitalSignatureAlgorithm : Swift.String, Swift.CaseIterable {
  case rs256
  case rs384
  case rs512
  case es256
  case es384
  case es512
  case unknown
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SAPFoundation.DigitalSignatureAlgorithm]
  public typealias RawValue = Swift.String
  public static var allCases: [SAPFoundation.DigitalSignatureAlgorithm] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public class DigitalSignatureParameter {
  public enum Padding {
    case PSS
    case PKCS1v1_5
    public static func == (a: SAPFoundation.DigitalSignatureParameter.Padding, b: SAPFoundation.DigitalSignatureParameter.Padding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(algorithm: SAPFoundation.DigitalSignatureAlgorithm, padding: SAPFoundation.DigitalSignatureParameter.Padding?)
  @objc deinit
}
public protocol DigitalSignatureVerifying {
  func verify(signature: Foundation.Data, on message: Foundation.Data, usingPublicKey publicKey: Swift.String, parameter: SAPFoundation.DigitalSignatureParameter) throws -> Swift.Bool
}
public class DigitalSignatureVerifier {
  public init()
  @objc deinit
}
extension SAPFoundation.DigitalSignatureVerifier : SAPFoundation.DigitalSignatureVerifying {
  public func verify(signature: Foundation.Data, on message: Foundation.Data, usingPublicKey publicKeyPem: Swift.String, parameter: SAPFoundation.DigitalSignatureParameter) throws -> Swift.Bool
}
public class EncryptionConfigLoader {
  public static let encryptionKeyID: Swift.String
  public init(sapURLSession: SAPFoundation.SAPURLSession, settingsParameters: SAPFoundation.SAPcpmsSettingsParameters)
  public func load(completionHandler: @escaping (Swift.String?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class ManagedConfigurationProvider : SAPFoundation.ConfigurationProviding {
  public init()
  public var providerIdentifier: Swift.String {
    get
  }
  public var expectedInput: [Swift.String : Any] {
    get
  }
  public func provideConfiguration(input: [Swift.String : Any] = [:]) -> (providerSuccess: Swift.Bool, configuration: Foundation.NSDictionary, returnError: (any Swift.Error)?)
  @objc deinit
}
public protocol BasicCredentialStoring : AnyObject {
  func store(credential: SAPFoundation.BasicCredential, for: Foundation.URL) throws
  func credential(for: Foundation.URL) throws -> SAPFoundation.BasicCredential?
  func delete(for: Foundation.URL) throws
}
public protocol SQLiteDatatypeBridgeable {
}
extension Swift.String : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.Bool : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.Float : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.Double : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.Int : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.Int8 : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.Int16 : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.Int32 : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.Int64 : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.UInt : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.UInt8 : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.UInt16 : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.UInt32 : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Swift.UInt64 : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Foundation.Data : SAPFoundation.SQLiteDatatypeBridgeable {
}
extension Foundation.Date : SAPFoundation.SQLiteDatatypeBridgeable {
}
public protocol CodableStoring : AnyObject {
  func get<T>(_ type: T.Type, for: Swift.String) throws -> T? where T : Swift.Decodable, T : Swift.Encodable
  func put<T>(_ value: T, for: Swift.String) throws where T : Swift.Decodable, T : Swift.Encodable
  func remove(for: Swift.String) throws
  func keys() throws -> Swift.Set<Swift.String>
}
public struct JWSParser : SAPFoundation.DigitallySignedMessageParser {
  public static func parse(_ input: Swift.String) throws -> any SAPFoundation.DigitallySignedMessage
  public typealias Input = Swift.String
}
public let SAPcpmsSettingsParametersBackendURL: Swift.String
public let SAPcpmsSettingsParametersApplicationID: Swift.String
public let SAPcpmsSettingsParametersDeviceID: Swift.String
public let SAPcpmsSettingsParametersApplicationVersion: Swift.String
public let CFBundleShortVersionString: Swift.String
public struct SAPcpmsSettingsParameters : Swift.Codable {
  public var backendURL: Foundation.URL
  public var applicationID: Swift.String
  public var deviceID: Swift.String?
  public var applicationVersion: Swift.String?
  public var destinations: [Swift.String : Swift.String]?
  public static let defaultApplicationVersion: Swift.String?
  public static let defaultApplicationID: Swift.String?
  public static let defaultDeviceID: Swift.String?
  @available(*, deprecated, renamed: "defaultDeviceID")
  public static let uuid: Swift.String?
  public init(backendURL: Foundation.URL, applicationID: Swift.String? = defaultApplicationID, deviceID: Swift.String? = defaultDeviceID, applicationVersion: Swift.String? = defaultApplicationVersion, destinations: [Swift.String : Swift.String]? = nil)
  public func url(forDestination name: Swift.String) -> Foundation.URL?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension SAPFoundation.SAPcpmsSettingsParameters : SAPFoundation.DiscoveryServiceConfigurable {
  public init(discoveryServiceConfig config: Any) throws
  public init(applicationID: Swift.String, discoveryServiceConfig config: Any) throws
}
extension SAPFoundation.SAPcpmsSettingsParameters : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class UsageSnapshot : SAPCommon.UsageSnapshotting {
  @objc deinit
  public func records(_ body: (SAPCommon.UsageRecord) -> Swift.Bool)
  public func recordCount() -> Swift.Int
  public func removeRecords()
}
extension SAPFoundation.IdentityError : Swift.Equatable {}
extension SAPFoundation.IdentityError : Swift.Hashable {}
extension SAPFoundation.SAPcpmsUserBlockedError : Swift.Equatable {}
extension SAPFoundation.SAPcpmsUserBlockedError : Swift.Hashable {}
extension SAPFoundation.AuthenticationObserverError : Swift.Equatable {}
extension SAPFoundation.AuthenticationObserverError : Swift.Hashable {}
extension SAPFoundation.ClipboardProtectionError : Swift.Equatable {}
extension SAPFoundation.ClipboardProtectionError : Swift.Hashable {}
extension SAPFoundation.DeviceComplianceDetectionPolicy : Swift.Equatable {}
extension SAPFoundation.DeviceComplianceDetectionPolicy : Swift.Hashable {}
extension SAPFoundation.DeviceComplianceDetectionPolicy : Swift.RawRepresentable {}
extension SAPFoundation.PrintPolicyEnforcerError : Swift.Equatable {}
extension SAPFoundation.PrintPolicyEnforcerError : Swift.Hashable {}
extension SAPFoundation.PrintPolicy : Swift.Equatable {}
extension SAPFoundation.PrintPolicy : Swift.Hashable {}
extension SAPFoundation.PrintPolicy : Swift.RawRepresentable {}
extension SAPFoundation.OAuth2TokenError : Swift.Hashable {}
extension SAPFoundation.SAPcpmsUserRolesError.MalformedType : Swift.Equatable {}
extension SAPFoundation.SAPcpmsUserRolesError.MalformedType : Swift.Hashable {}
extension SAPFoundation.OpenURLPolicyEnforcerError : Swift.Equatable {}
extension SAPFoundation.OpenURLPolicyEnforcerError : Swift.Hashable {}
extension SAPFoundation.UsageBrokerError : Swift.Equatable {}
extension SAPFoundation.UsageBrokerError : Swift.Hashable {}
extension SAPFoundation.SAPcpmsSettings.SettingsTarget : Swift.Equatable {}
extension SAPFoundation.SAPcpmsSettings.SettingsTarget : Swift.Hashable {}
extension SAPFoundation.SAPcpmsRemoteNotificationError.MalformedType : Swift.Equatable {}
extension SAPFoundation.SAPcpmsRemoteNotificationError.MalformedType : Swift.Hashable {}
extension SAPFoundation.SAPcpmsDestinationsError.MalformedType : Swift.Equatable {}
extension SAPFoundation.SAPcpmsDestinationsError.MalformedType : Swift.Hashable {}
extension SAPFoundation.ComponentType : Swift.Equatable {}
extension SAPFoundation.ComponentType : Swift.Hashable {}
extension SAPFoundation.ComponentType : Swift.RawRepresentable {}
extension SAPFoundation.TraceFlags : Swift.Equatable {}
extension SAPFoundation.TraceFlags : Swift.Hashable {}
extension SAPFoundation.TraceFlags : Swift.RawRepresentable {}
extension SAPFoundation.BasicCredentialDiscoveryError : Swift.Equatable {}
extension SAPFoundation.BasicCredentialDiscoveryError : Swift.Hashable {}
extension SAPFoundation.ClipboardAccessPolicy : Swift.Equatable {}
extension SAPFoundation.ClipboardAccessPolicy : Swift.Hashable {}
extension SAPFoundation.ClipboardAccessPolicy : Swift.RawRepresentable {}
extension SAPFoundation.OpenURLPolicy : Swift.Equatable {}
extension SAPFoundation.OpenURLPolicy : Swift.Hashable {}
extension SAPFoundation.OpenURLPolicy : Swift.RawRepresentable {}
extension SAPFoundation.SLSLoginInputField.InputType : Swift.Equatable {}
extension SAPFoundation.SLSLoginInputField.InputType : Swift.Hashable {}
extension SAPFoundation.ApplicationVersioningError : Swift.Equatable {}
extension SAPFoundation.ApplicationVersioningError : Swift.Hashable {}
extension SAPFoundation.SAPcpmsSettingsError.MalformedType : Swift.Equatable {}
extension SAPFoundation.SAPcpmsSettingsError.MalformedType : Swift.Hashable {}
extension SAPFoundation.UserIdentityObserverError : Swift.Equatable {}
extension SAPFoundation.UserIdentityObserverError : Swift.Hashable {}
extension SAPFoundation.ReachabilityType : Swift.Equatable {}
extension SAPFoundation.ReachabilityType : Swift.Hashable {}
extension SAPFoundation.SLSLoginInput.ClientMessageType : Swift.Equatable {}
extension SAPFoundation.SLSLoginInput.ClientMessageType : Swift.Hashable {}
extension SAPFoundation.SLSLoginInput.ClientMessageType : Swift.RawRepresentable {}
extension SAPFoundation.SecurityManagerError : Swift.Equatable {}
extension SAPFoundation.SecurityManagerError : Swift.Hashable {}
extension SAPFoundation.DigitalSignatureAlgorithm : Swift.Equatable {}
extension SAPFoundation.DigitalSignatureAlgorithm : Swift.Hashable {}
extension SAPFoundation.DigitalSignatureAlgorithm : Swift.RawRepresentable {}
extension SAPFoundation.DigitalSignatureParameter.Padding : Swift.Equatable {}
extension SAPFoundation.DigitalSignatureParameter.Padding : Swift.Hashable {}
