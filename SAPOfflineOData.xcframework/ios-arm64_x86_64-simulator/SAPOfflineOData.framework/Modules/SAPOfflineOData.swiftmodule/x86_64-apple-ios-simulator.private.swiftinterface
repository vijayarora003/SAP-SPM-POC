// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target x86_64-apple-ios16.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SAPOfflineOData
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CryptoKit
import Foundation
import SAPCommon
import SAPFoundation
import SAPOData
@_exported import SAPOfflineOData
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum OfflineODataOperationStep : Swift.Int {
  case buildingEntityStore
  case creatingBootStrapDatabase
  case creatingRequestQueueDatabase
  case downloadingEntityStore
  case erasingExpiredRequests
  case loadingMetadata
  case performingRequestQueueMerge
  case performingTransactionMerge
  case performingCreateDeleteMerge
  case processingDefiningQueries
  case processingRequests
  case reapplyingChanges
  case analyzingReceivedData
  case receivingDataFromServer
  case removingDeletedRelationships
  case removingRemoveAfterUploadRequests
  case sendingDataToServer
  case sendingEntityStoreDatabase
  case sendingRequestQueueDatabase
  case uploadPreprocessing
  case waitingForDownload
  case upgradingSchema
  case reBootstrapingDatabase
  case upgradingClientOnlyDatabase
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers open class OfflineODataRequestOptions : SAPOData.RequestOptions {
  override public init()
  open var removeCreatedEntityAfterUpload: Swift.Bool {
    get
    set(value)
  }
  open var unmodifiableRequest: Swift.Bool {
    get
    set(value)
  }
  open var transactionID: SAPOfflineOData.TransactionID? {
    get
    set(value)
  }
  open var uploadCategory: SAPOfflineOData.UploadCategory? {
    get
    set(value)
  }
  open var customHeaderFormat: Swift.String? {
    get
    set(value)
  }
  @objc deinit
}
public enum TransactionIDType {
  case stringLiteral
  case entityValue
  case useGeneratedIDForTransactionID
  public static func == (a: SAPOfflineOData.TransactionIDType, b: SAPOfflineOData.TransactionIDType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TransactionID {
  public static let useGeneratedIDForTransactionID: SAPOfflineOData.TransactionID
  public init(entity: SAPOData.EntityValue)
  public init(stringLiteral: Swift.String) throws
  public var transactionIDType: SAPOfflineOData.TransactionIDType {
    get
  }
  public var stringLiteral: Swift.String {
    get
  }
  public var entityValue: SAPOData.EntityValue {
    get
  }
  @objc deinit
}
public enum UploadCategoryType {
  case stringLiteral
  case entityValue
  case useGeneratedIDForUploadCategory
  public static func == (a: SAPOfflineOData.UploadCategoryType, b: SAPOfflineOData.UploadCategoryType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class UploadCategory {
  public static func useGeneratedIDForUploadCategory() -> SAPOfflineOData.UploadCategory
  public init(entity: SAPOData.EntityValue)
  public init(stringLiteral: Swift.String) throws
  public var uploadCategoryType: SAPOfflineOData.UploadCategoryType {
    get
  }
  public var stringLiteral: Swift.String {
    get
  }
  public var entityValue: SAPOData.EntityValue {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class OperationSessionInfo : ObjectiveC.NSObject {
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class OfflineODataProviderProgressInternal : ObjectiveC.NSObject {
  @objc public var step: Swift.Int
  @objc public var totalNumberOfSteps: Swift.Int
  @objc public var currentStepNumber: Swift.Int
  @objc public var parameters: Foundation.NSArray
  @objc public var defaultMessage: Swift.String
  @objc public var sessionInfo: SAPOfflineOData.OperationSessionInfo?
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class OfflineODataProviderDelegateInternal : ObjectiveC.NSObject {
  @objc public func containsDelegate() -> Swift.Bool
  @objc public func setMetadataUpdated()
  @objc public func setNeedUpgradeClientOnlyDatabase()
  @objc public func openProgressUpdate(_ progressInternal: SAPOfflineOData.OfflineODataProviderProgressInternal)
  @objc public func downloadProgressUpdate(_ progressInternal: SAPOfflineOData.OfflineODataProviderProgressInternal)
  @objc public func uploadProgressUpdate(_ progressInternal: SAPOfflineOData.OfflineODataProviderProgressInternal)
  @objc public func requestFailed(_ request: SAPOfflineOData.OfflineODataFailedRequestInternal)
  @objc public func sendStoreProgressUpdate(_ progressInternal: SAPOfflineOData.OfflineODataProviderProgressInternal)
  @objc public func createProgressStatusServerPullingObject(_ sessionInfo: SAPOfflineOData.OperationSessionInfo) -> SAPOfflineOData.ServerProgressPulling?
  @objc deinit
}
public struct OfflineODataDefiningQuery {
  public var name: Swift.String
  public var query: Swift.String
  public var automaticallyRetrievesStreams: Swift.Bool
  public var isRemoving: Swift.Bool
  public init(name: Swift.String, query: Swift.String, automaticallyRetrievesStreams: Swift.Bool)
  public init(name: Swift.String, query: SAPOData.DataQuery, automaticallyRetrievesStreams: Swift.Bool)
}
@_hasMissingDesignatedInitializers public class OfflineODataCustomHeader : SAPOData.EntityValue {
  @inline(__always) open class var headerID: SAPOData.Property {
    get
    set(value)
  }
  open var headerID: Swift.Int {
    get
    set(value)
  }
  override open var isProxy: Swift.Bool {
    get
  }
  open class func key(headerID: Swift.Int) -> SAPOData.EntityKey
  @inline(__always) open class var name: SAPOData.Property {
    get
    set(value)
  }
  open var name: Swift.String {
    get
    set(value)
  }
  @inline(__always) open class var value: SAPOData.Property {
    get
    set(value)
  }
  open var value: Swift.String {
    get
    set(value)
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class OfflineODataErrorArchiveEntity : SAPOData.EntityValue {
  @inline(__always) open class var affectedEntity: SAPOData.Property {
    get
    set(value)
  }
  open var affectedEntity: SAPOData.EntityValue? {
    get
    set(value)
  }
  @inline(__always) open class var code: SAPOData.Property {
    get
    set(value)
  }
  open var code: Swift.String? {
    get
    set(value)
  }
  @inline(__always) open class var customHeaders: SAPOData.Property {
    get
    set(value)
  }
  open var customHeaders: Swift.Array<SAPOfflineOData.OfflineODataCustomHeader> {
    get
    set(value)
  }
  @inline(__always) open class var customTag: SAPOData.Property {
    get
    set(value)
  }
  open var customTag: Swift.String? {
    get
    set(value)
  }
  @inline(__always) open class var dependentRequests: SAPOData.Property {
    get
    set(value)
  }
  open var dependentRequests: Swift.Array<SAPOfflineOData.OfflineODataRequest> {
    get
    set(value)
  }
  @inline(__always) open class var domain: SAPOData.Property {
    get
    set(value)
  }
  open var domain: Swift.String {
    get
    set(value)
  }
  @inline(__always) open class var httpStatusCode: SAPOData.Property {
    get
    set(value)
  }
  open var httpStatusCode: Swift.Int? {
    get
    set(value)
  }
  @inline(__always) open class var innerError: SAPOData.Property {
    get
    set(value)
  }
  open var innerError: Swift.String? {
    get
    set(value)
  }
  override open var isProxy: Swift.Bool {
    get
  }
  @inline(__always) open class var message: SAPOData.Property {
    get
    set(value)
  }
  open var message: Swift.String? {
    get
    set(value)
  }
  @inline(__always) open class var requestBody: SAPOData.Property {
    get
    set(value)
  }
  open var requestBody: Swift.String? {
    get
    set(value)
  }
  @inline(__always) open class var requestEntity: SAPOData.Property {
    get
    set(value)
  }
  open var requestEntity: SAPOData.EntityValue? {
    get
    set(value)
  }
  @inline(__always) open class var requestID: SAPOData.Property {
    get
    set(value)
  }
  open var requestID: Swift.Int64 {
    get
    set(value)
  }
  @inline(__always) open class var requestMethod: SAPOData.Property {
    get
    set(value)
  }
  open var requestMethod: Swift.String? {
    get
    set(value)
  }
  @inline(__always) open class var requestURL: SAPOData.Property {
    get
    set(value)
  }
  open var requestURL: Swift.String? {
    get
    set(value)
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class OfflineODataEvent : SAPOData.EntityValue {
  @inline(__always) open class var details: SAPOData.Property {
    get
    set(value)
  }
  open var details: Swift.String? {
    get
    set(value)
  }
  @inline(__always) open class var id: SAPOData.Property {
    get
    set(value)
  }
  open var id: Swift.Int64 {
    get
    set(value)
  }
  override open var isProxy: Swift.Bool {
    get
  }
  @inline(__always) open class var time: SAPOData.Property {
    get
    set(value)
  }
  open var time: SAPOData.GlobalDateTime? {
    get
    set(value)
  }
  @inline(__always) open class var eventType: SAPOData.Property {
    get
    set(value)
  }
  open var eventType: Swift.String {
    get
    set(value)
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class OfflineODataRequest : SAPOData.EntityValue {
  @inline(__always) open class var affectedEntity: SAPOData.Property {
    get
    set(value)
  }
  open var affectedEntity: SAPOData.EntityValue? {
    get
    set(value)
  }
  @inline(__always) open class var body: SAPOData.Property {
    get
    set(value)
  }
  open var body: Swift.String? {
    get
    set(value)
  }
  @inline(__always) open class var customHeaders: SAPOData.Property {
    get
    set(value)
  }
  open var customHeaders: Swift.Array<SAPOfflineOData.OfflineODataCustomHeader> {
    get
    set(value)
  }
  @inline(__always) open class var customTag: SAPOData.Property {
    get
    set(value)
  }
  open var customTag: Swift.String? {
    get
    set(value)
  }
  @inline(__always) open class var dependentRequests: SAPOData.Property {
    get
    set(value)
  }
  open var dependentRequests: Swift.Array<SAPOfflineOData.OfflineODataRequest> {
    get
    set(value)
  }
  override open var isProxy: Swift.Bool {
    get
  }
  @inline(__always) open class var method: SAPOData.Property {
    get
    set(value)
  }
  open var method: Swift.String {
    get
    set(value)
  }
  @inline(__always) open class var requestID: SAPOData.Property {
    get
    set(value)
  }
  open var requestID: Swift.Int64 {
    get
    set(value)
  }
  @inline(__always) open class var status: SAPOData.Property {
    get
    set(value)
  }
  open var status: Swift.String {
    get
    set(value)
  }
  @inline(__always) open class var url: SAPOData.Property {
    get
    set(value)
  }
  open var url: Swift.String? {
    get
    set(value)
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class OfflineODataQueryFunction : SAPOData.QueryFunction {
  public static func isLocal() -> SAPOData.QueryFilter
  public static func hasPendingChanges() -> SAPOData.QueryFilter
  public static func inErrorState() -> SAPOData.QueryFilter
  public static func entityExists(_ property: SAPOData.DataPath) -> SAPOData.QueryFilter
  public static func upsertedLastDownload() -> SAPOData.QueryFilter
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class ServerProgressPulling : ObjectiveC.NSObject {
  @objc public func startPulling()
  @objc public func stopPulling()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class EntityKeyInfo {
  public func isNavigationUsedAsKey(_ entityType: SAPOData.EntityType, _ navName: Swift.String) -> Swift.Bool
  public func isPathUsedAsKey(_ entityType: SAPOData.EntityType, _ path: Swift.String) -> Swift.Bool
  public func getKeyPropertyByPath(_ entityType: SAPOData.EntityType, _ path: Swift.String) -> SAPOData.Property?
  public func getRefConstainNameByPath(_ entityType: SAPOData.EntityType, _ path: Swift.String) -> Swift.String?
  @objc deinit
}
public protocol OfflineODataProviderProgressReporting {
  var operationId: Swift.String { get }
  var currentStepNumber: Swift.Int { get }
  var totalNumberOfSteps: Swift.Int { get }
  var time: SAPOData.GlobalDateTime { get }
  var step: SAPOfflineOData.OfflineODataOperationStep { get }
  var parameters: [Swift.String] { get }
  var defaultMessage: Swift.String { get }
}
public struct OfflineODataProviderOperationProgress : SAPOfflineOData.OfflineODataProviderProgressReporting {
  public var operationId: Swift.String {
    get
  }
  public var currentStepNumber: Swift.Int {
    get
  }
  public var totalNumberOfSteps: Swift.Int {
    get
  }
  public var time: SAPOData.GlobalDateTime {
    get
  }
  public var step: SAPOfflineOData.OfflineODataOperationStep {
    get
  }
  public var parameters: [Swift.String] {
    get
  }
  public var defaultMessage: Swift.String {
    get
  }
}
public struct OfflineODataProviderDownloadProgress : SAPOfflineOData.OfflineODataProviderProgressReporting {
  public var operationId: Swift.String {
    get
  }
  public var currentStepNumber: Swift.Int {
    get
  }
  public var totalNumberOfSteps: Swift.Int {
    get
  }
  public var time: SAPOData.GlobalDateTime {
    get
  }
  public var step: SAPOfflineOData.OfflineODataOperationStep {
    get
  }
  public var parameters: [Swift.String] {
    get
  }
  public var defaultMessage: Swift.String {
    get
  }
  public var subset: [SAPOfflineOData.OfflineODataDefiningQuery]? {
    get
  }
}
public struct OfflineODataFailedRequest {
  public var httpStatusCode: Swift.Int {
    get
  }
  public var requestID: Swift.Int {
    get
  }
  public var customTag: Swift.String? {
    get
  }
  public var errorCode: Swift.String {
    get
  }
  public var errorMessage: Swift.String {
    get
  }
  public var innerError: Swift.String? {
    get
  }
  public var requestHTTPMethod: Swift.String {
    get
  }
  public var requestURL: Foundation.URL {
    get
  }
  public var requestBody: Swift.String? {
    get
  }
}
public protocol OfflineODataProviderDelegate {
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateOpenProgress progress: SAPOfflineOData.OfflineODataProviderOperationProgress)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateDownloadProgress progress: SAPOfflineOData.OfflineODataProviderDownloadProgress)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateUploadProgress progress: SAPOfflineOData.OfflineODataProviderOperationProgress)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, requestDidFail request: SAPOfflineOData.OfflineODataFailedRequest)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateSendStoreProgress progress: SAPOfflineOData.OfflineODataProviderOperationProgress)
  var cloudProgressPullInterval: Swift.Int { get }
}
extension SAPOfflineOData.OfflineODataProviderDelegate {
  public var cloudProgressPullInterval: Swift.Int {
    get
  }
}
open class OfflineODataProvider : SAPOData.DataServiceProvider {
  open var syncProvider: any SAPOData.DataSyncProvider {
    get
  }
  public var providerParameters: SAPOfflineOData.OfflineODataParameters {
    get
  }
  public var serviceOptions: SAPOfflineOData.OfflineODataServiceOptions
  public static var libraryVersion: Swift.String {
    get
  }
  @available(swift, deprecated: 5.1, message: "OfflineODataDelegate will be replaced by OfflineODataProviderDelegate.")
  public init(serviceRoot: Foundation.URL, parameters: SAPOfflineOData.OfflineODataParameters, sapURLSession: SAPFoundation.SAPURLSession, delegate: any SAPOfflineOData.OfflineODataDelegate) throws
  convenience public init(serviceRoot: Foundation.URL, parameters: SAPOfflineOData.OfflineODataParameters) throws
  @available(swift, deprecated: 5.1, message: "OfflineODataDelegate will be replaced by OfflineODataProviderDelegate.")
  public init(serviceRoot: Foundation.URL, parameters: SAPOfflineOData.OfflineODataParameters, delegate: any SAPOfflineOData.OfflineODataDelegate) throws
  public init(serviceRoot: Foundation.URL, parameters: SAPOfflineOData.OfflineODataParameters, sapURLSession: SAPFoundation.SAPURLSession, delegate: (any SAPOfflineOData.OfflineODataProviderDelegate)? = nil) throws
  public init(serviceRoot: Foundation.URL, parameters: SAPOfflineOData.OfflineODataParameters, delegate: (any SAPOfflineOData.OfflineODataProviderDelegate)? = nil) throws
  open var serviceName: Swift.String {
    get
  }
  open var serviceName_NS: Foundation.NSString {
    get
  }
  open var hasMetadata: Swift.Bool {
    get
  }
  open var metadata: SAPOData.CSDLDocument {
    get
    set(value)
  }
  public var logger: SAPCommon.Logger {
    get
    set(value)
  }
  public static func clear(at path: Foundation.URL?, withName name: Swift.String?) throws
  public func clear() throws
  public func close() throws
  public func requestQueueIsEmpty() throws -> Swift.Bool
  public func hasPendingDownload() throws -> Swift.Bool
  public func hasPendingUpload() throws -> Swift.Bool
  public func open(completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func getPreviousUser() throws -> Swift.String?
  public func upload(completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func upload(categories: [SAPOfflineOData.UploadCategory], completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  @discardableResult
  public func download(completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void) -> SAPOData.CancelToken
  public func forceReauthentication(completionHandler: @escaping () -> Swift.Void)
  @discardableResult
  public func download(withSubset subset: [SAPOfflineOData.OfflineODataDefiningQuery], completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void) -> SAPOData.CancelToken
  public func cancelDownload() throws
  public func cancelUpload() throws
  public func sendStore(note: Swift.String? = nil, completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func sendEncryptedStore(newEncryptionKey: Swift.String, note: Swift.String? = nil, completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func add(definingQuery: SAPOfflineOData.OfflineODataDefiningQuery) throws
  public func setDefiningQueryGroups(groups: Swift.Array<Swift.Set<Swift.String>>) throws
  public func remove(definingQuery: SAPOfflineOData.OfflineODataDefiningQuery) throws
  public func remove(definingQuery: SAPOfflineOData.OfflineODataDefiningQuery, completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  open func createEntity(_ entity: SAPOData.EntityValue, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func createLink(from: SAPOData.EntityValue, property: SAPOData.Property, to: SAPOData.EntityValue, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func createMedia(entity: SAPOData.EntityValue, content: SAPOData.StreamBase, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func deleteByQuery(_ query: SAPOData.DataQuery, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func deleteEntity(_ entity: SAPOData.EntityValue, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func deleteStream(entity: SAPOData.EntityValue, link: SAPOData.StreamLink, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func deleteLink(from: SAPOData.EntityValue, property: SAPOData.Property, to: SAPOData.EntityValue, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func downloadMedia(entity: SAPOData.EntityValue, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws -> SAPOData.ByteStream
  open func downloadStream(entity: SAPOData.EntityValue, link: SAPOData.StreamLink, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws -> SAPOData.ByteStream
  open func executeQuery(_ query: SAPOData.DataQuery, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws -> SAPOData.QueryResult
  open func fetchErrorArchive(query: SAPOData.DataQuery = DataQuery()) throws -> Swift.Array<SAPOfflineOData.OfflineODataErrorArchiveEntity>
  open func fetchEventLog(query: SAPOData.DataQuery = DataQuery()) throws -> Swift.Array<SAPOfflineOData.OfflineODataEvent>
  open func getLastDownloadTime() throws -> SAPOData.GlobalDateTime?
  open func getLastUploadTime() throws -> SAPOData.GlobalDateTime?
  open func processBatch(_ batch: SAPOData.RequestBatch, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func updateEntity(_ entity: SAPOData.EntityValue, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func updateLink(from: SAPOData.EntityValue, property: SAPOData.Property, to: SAPOData.EntityValue, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func uploadMedia(entity: SAPOData.EntityValue, content: SAPOData.StreamBase, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  open func uploadStream(entity: SAPOData.EntityValue, link: SAPOData.StreamLink, content: SAPOData.StreamBase, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws
  public func logRequestQueue(level: SAPCommon.LogLevel = SAPCommon.LogLevel.debug) throws
  public func logDefiningQueries(level: SAPCommon.LogLevel = SAPCommon.LogLevel.debug) throws
  public func getDefiningQueries() throws -> Swift.Array<SAPOfflineOData.OfflineODataDefiningQuery>
  open func executeMethod(_ method: SAPOData.DataMethod, parameters: SAPOData.ParameterList, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws -> SAPOData.DataValue?
  open func pingServer(headers: SAPOData.HTTPHeaders = HTTPHeaders.empty, options: SAPOData.RequestOptions = RequestOptions.none) throws
  open func undoPendingChanges(for entity: SAPOData.EntityValue) throws
  open func undoPendingChanges(for entities: [SAPOData.EntityValue]) throws
  open func undoPendingChanges(for uploadCategory: SAPOfflineOData.UploadCategory) throws
  open func undoPendingChanges(for transactionId: SAPOfflineOData.TransactionID) throws
  open func undoPendingChanges(headerName: Swift.String, headerValue: Swift.String) throws
  open func loadMetadata(headers: SAPOData.HTTPHeaders = HTTPHeaders.empty, options: SAPOData.RequestOptions = RequestOptions.none) throws
  open func unloadMetadata() throws
  open func fetchMetadata(headers: SAPOData.HTTPHeaders = HTTPHeaders.empty, options: SAPOData.RequestOptions = RequestOptions.none) throws -> SAPOData.CSDLDocument
  public func purgeClientOnlyData() throws
  @objc deinit
}
@_inheritsConvenienceInitializers @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
@objc public class OfflineODataProgressInternal : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var bytesSent: Swift.Int
  @objc public var bytesReceived: Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
@objc public class OfflineODataFileDownloadProgressInternal : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var bytesReceived: Swift.Int
  @objc public var fileSize: Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
@objc public class OfflineODataSendStoreProgressInternal : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var currentFileBytesSent: Swift.Int
  @objc public var currentFileSize: Swift.Int
  @objc public var currentFileIndex: Swift.Int
  @objc public var currentFileName: Swift.String
  @objc public var totalNumberOfFiles: Swift.Int
  @objc public var totalSize: Swift.Int
  @objc public var totalBytesSent: Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class OfflineODataFailedRequestInternal : ObjectiveC.NSObject {
  @objc public var httpStatusCode: Swift.Int
  @objc public var requestID: Swift.Int
  @objc public var customTag: Swift.String?
  @objc public var errorCode: Swift.String
  @objc public var errorMessage: Swift.String
  @objc public var innerError: Swift.String?
  @objc public var requestHTTPMethod: Swift.String
  @objc public var requestURL: Swift.String
  @objc public var requestBody: Swift.String?
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class OfflineODataDelegateInternal : ObjectiveC.NSObject {
  @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available in OfflineODataProviderDelegate.")
  @objc public func downloadProgress(_ progressStatus: SAPOfflineOData.OfflineODataProgressInternal)
  @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available in OfflineODataProviderDelegate.")
  @objc public func fileDownloadProgress(_ progressStatus: SAPOfflineOData.OfflineODataFileDownloadProgressInternal)
  @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available in OfflineODataProviderDelegate.")
  @objc public func uploadProgress(_ progressStatus: SAPOfflineOData.OfflineODataProgressInternal)
  @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available in OfflineODataProviderDelegate.")
  @objc public func sendStoreProgress(_ progressStatus: SAPOfflineOData.OfflineODataSendStoreProgressInternal)
  @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available in OfflineODataProviderDelegate.")
  @objc public func requestFailed(_ request: SAPOfflineOData.OfflineODataFailedRequestInternal)
  @available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available in OfflineODataProviderDelegate.")
  @objc public func stateChanged(_ newState: Swift.Int)
  @objc deinit
}
@objc public enum OfflineODataClientLogLevelInternal : Swift.Int {
  case None = 1
  case Fatal = 2
  case Error = 3
  case Warning = 4
  case Info = 5
  case Debug = 6
  case All = 7
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class OfflineODataLoggerInternal : ObjectiveC.NSObject {
  public var logger: SAPCommon.Logger {
    get
    set(value)
  }
  @objc public func getLogLevel() -> SAPOfflineOData.OfflineODataClientLogLevelInternal
  @objc public func log(_ clientLogLevel: SAPOfflineOData.OfflineODataClientLogLevelInternal, message: Swift.String)
  @objc deinit
}
@available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
public struct OfflineODataProgress {
  public var bytesSent: Swift.Int {
    get
  }
  public var bytesReceived: Swift.Int {
    get
  }
}
@available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
public struct OfflineODataFileDownloadProgress {
  public var bytesReceived: Swift.Int {
    get
  }
  public var fileSize: Swift.Int {
    get
  }
}
@available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
public struct OfflineODataSendStoreProgress {
  public var currentFileBytesSent: Swift.Int {
    get
  }
  public var currentFileSize: Swift.Int {
    get
  }
  public var currentFileIndex: Swift.Int {
    get
  }
  public var currentFileName: Swift.String {
    get
  }
  public var totalNumberOfFiles: Swift.Int {
    get
  }
  public var totalSize: Swift.Int {
    get
  }
  public var totalBytesSent: Swift.Int {
    get
  }
}
@available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
public struct OfflineODataStoreState : Swift.OptionSet {
  public init(rawValue: Swift.Int)
  public let rawValue: Swift.Int
  public static let opening: SAPOfflineOData.OfflineODataStoreState
  public static let initializing: SAPOfflineOData.OfflineODataStoreState
  public static let initialCommunication: SAPOfflineOData.OfflineODataStoreState
  public static let fileDownloading: SAPOfflineOData.OfflineODataStoreState
  public static let downloading: SAPOfflineOData.OfflineODataStoreState
  public static let uploading: SAPOfflineOData.OfflineODataStoreState
  public static let open: SAPOfflineOData.OfflineODataStoreState
  public static let closed: SAPOfflineOData.OfflineODataStoreState
  public static let sendingStore: SAPOfflineOData.OfflineODataStoreState
  public typealias ArrayLiteralElement = SAPOfflineOData.OfflineODataStoreState
  public typealias Element = SAPOfflineOData.OfflineODataStoreState
  public typealias RawValue = Swift.Int
}
@available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
public protocol OfflineODataDelegate {
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateDownloadProgress progress: SAPOfflineOData.OfflineODataProgress)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateFileDownloadProgress progress: SAPOfflineOData.OfflineODataFileDownloadProgress)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateUploadProgress progress: SAPOfflineOData.OfflineODataProgress)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, requestDidFail request: SAPOfflineOData.OfflineODataFailedRequest)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, stateDidChange newState: SAPOfflineOData.OfflineODataStoreState)
  func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateSendStoreProgress progress: SAPOfflineOData.OfflineODataSendStoreProgress)
}
@available(swift, deprecated: 5.1, message: "New functions for obtaining progress information for open, download, upload, and sendStore are available using OfflineODataProviderDelegate.")
extension SAPOfflineOData.OfflineODataDelegate {
  public func offlineODataProvider(_ provider: SAPOfflineOData.OfflineODataProvider, didUpdateSendStoreProgress progress: SAPOfflineOData.OfflineODataSendStoreProgress)
}
public enum OfflineODataError : Swift.Error {
  case error(code: Swift.Int, message: Swift.String)
  case invalidInput(code: Swift.Int, message: Swift.String)
  case preconditionFailed(code: Swift.Int, message: Swift.String)
  case notFound(code: Swift.Int, message: Swift.String)
  case communicationError(code: Swift.Int, message: Swift.String)
  case serverSideError(code: Swift.Int, message: Swift.String)
  case clientInternalError(code: Swift.Int, message: Swift.String)
  case notSupported(code: Swift.Int, message: Swift.String)
  public var errorName: SAPOfflineOData.OfflineODataErrorName {
    get
  }
  public var message: Swift.String? {
    get
  }
  public var code: Swift.Int {
    get
  }
  public func toString() -> Swift.String
}
extension SAPOfflineOData.OfflineODataError : SAPCommon.SAPError {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
extension SAPOfflineOData.OfflineODataError : Foundation.CustomNSError {
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@_hasMissingDesignatedInitializers public class OfflineODataMetadata {
  @_hasMissingDesignatedInitializers public class EntityTypes {
    public static var errorArchiveEntity: SAPOData.EntityType {
      get
    }
    public static var event: SAPOData.EntityType {
      get
    }
    public static var request: SAPOData.EntityType {
      get
    }
    public static var customHeader: SAPOData.EntityType {
      get
    }
    @objc deinit
  }
  @_hasMissingDesignatedInitializers public class EntitySets {
    public static var errorArchive: SAPOData.EntitySet {
      get
    }
    public static var eventLog: SAPOData.EntitySet {
      get
    }
    public static var requestQueue: SAPOData.EntitySet {
      get
    }
    @objc deinit
  }
  @objc deinit
}
extension SAPOData.LegacyDataService where Provider : SAPOfflineOData.OfflineODataProvider {
  public func clear() throws
  public func close() throws
  public func requestQueueIsEmpty() throws -> Swift.Bool
  public func hasPendingDownload() throws -> Swift.Bool
  public func hasPendingUpload() throws -> Swift.Bool
  public func open(completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func upload(completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func upload(categories: [SAPOfflineOData.UploadCategory], completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  @discardableResult
  public func download(completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void) -> SAPOData.CancelToken
  @discardableResult
  public func download(withSubset subset: [SAPOfflineOData.OfflineODataDefiningQuery], completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void) -> SAPOData.CancelToken
  public func add(definingQuery: SAPOfflineOData.OfflineODataDefiningQuery) throws
  public func remove(definingQuery: SAPOfflineOData.OfflineODataDefiningQuery) throws
  public func remove(definingQuery: SAPOfflineOData.OfflineODataDefiningQuery, completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func cancelDownload() throws
  public func cancelUpload() throws
  public func sendStore(note: Swift.String? = nil, completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func sendEncryptedStore(newEncryptionKey: Swift.String, note: Swift.String? = nil, completionHandler: @escaping (_ error: SAPOfflineOData.OfflineODataError?) -> Swift.Void)
  public func forceReauthentication(completionHandler: @escaping () -> Swift.Void)
  public func logRequestQueue(level: SAPCommon.LogLevel = SAPCommon.LogLevel.debug) throws
  public func logDefiningQueries(level: SAPCommon.LogLevel = SAPCommon.LogLevel.debug) throws
  public func fetchErrorArchive(query: SAPOData.DataQuery = DataQuery()) throws -> Swift.Array<SAPOfflineOData.OfflineODataErrorArchiveEntity>
  public func fetchEventLog(query: SAPOData.DataQuery = DataQuery()) throws -> Swift.Array<SAPOfflineOData.OfflineODataEvent>
  public func undoPendingChanges(for entity: SAPOData.EntityValue) throws
  public func undoPendingChanges(for entities: [SAPOData.EntityValue]) throws
  public func getPreviousUser() throws -> Swift.String?
  public func executeMethod(_ method: SAPOData.DataMethod, parameters: SAPOData.ParameterList, headers: SAPOData.HTTPHeaders, options: SAPOData.RequestOptions) throws -> SAPOData.DataValue?
  public func getDefiningQueries() throws -> Swift.Array<SAPOfflineOData.OfflineODataDefiningQuery>
}
public class OfflineODataParameters {
  public var storeEncryptionKey: Swift.String?
  public var storeName: Swift.String?
  public var storePath: Foundation.URL?
  public var urlSuffix: Swift.String?
  public var extraStreamParameters: Swift.String?
  public var extraDatabaseConnectionParameters: Swift.String?
  public var customHeaders: [Swift.String : Swift.String]
  public var customCookies: [Swift.String : Swift.String]
  public var enableRepeatableRequests: Swift.Bool
  public static let noPaging: Swift.Int?
  public var pageSize: Swift.Int?
  public var timeout: Swift.Int32?
  public var enableRequestQueueOptimization: Swift.Bool
  public var enableUndoLocalCreation: Swift.Bool
  public var enableTransactionBuilder: Swift.Bool
  public var enableIndividualErrorArchiveDeletion: Swift.Bool
  public var enableBackgroundDataTransfer: Swift.Bool
  public var forceUploadOnUserSwitch: Swift.Bool
  public var refreshInOrderOfAddition: Swift.Bool
  public var autoRegisterClient: Swift.Bool
  public var currentUser: Swift.String?
  public var enableClientOnlyMetadata: Swift.Bool
  public var forcePurgeClientOnlyDataOnUserSwitch: Swift.Bool
  public var forcePurgeClientOnlyDataOnMetadataChange: Swift.Bool
  public init()
  @objc deinit
}
public struct OfflineODataServiceOptions {
  public var supportsBatch: Swift.Bool {
    get
    set(value)
  }
  public var supportsPatch: Swift.Bool {
    get
    set(value)
  }
  public var supportsBind: Swift.Bool {
    get
    set(value)
  }
  public var csdlOptions: Swift.Int {
    get
    set(value)
  }
}
public enum OfflineODataErrorName : Swift.RawRepresentable {
  public typealias RawValue = Swift.Int
  case noneException
  case debugException
  case errorExecutingSqlStmt
  case externalException
  case errorConnectingToDb
  case dbNotFound
  case errorLoadingEdmMetadata
  case errorLoadingMapping
  case fatalParseError
  case urlSyntaxError
  case unexpectedEoi
  case illegalTypeValue
  case emptyResourcePath
  case invalidEntityContainer
  case invalidKeyPredicate
  case invalidUnnamedKeyValue
  case wrongNumberOfKeyValues
  case invalidKeyProperty
  case duplicateKeyProperty
  case invalidKeyPropertyType
  case invalidNullInKeyPredicate
  case invalidProperty
  case invalidEmptyParen
  case invalidPathSegmentAfterProp
  case invalidPathSegmentAfterE_set
  case errorSettingParameter
  case duplicateQueryOption
  case notPositiveTop
  case negativeSkip
  case orderByMustEndWithProperty
  case errorLoadingDbMetadata
  case storeAlreadyOpen
  case storePreviouslyClosed
  case storeNotOpen
  case errorExpandingDeployFile
  case errorInitializingStore
  case unsupportedKeyWord
  case unableToDeleteDb
  case couldNotCreateDb
  case invalidPropertyValueType
  case invalidUseOfExpand
  case invalidNavigationProperty
  case invalidUseOfSelect
  case selectOfNonExpandedItem
  case followedPropertyInSelect
  case invalidUseOfTop
  case invalidUseOfSkip
  case orderByOfNonExpandedItem
  case invalidUseOfOrderBy
  case errorStmtNotPrepared
  case invalidUseOfFilter
  case filterMustBeBoolean
  case invalidArithmeticType
  case typesNotPromotable
  case genericFilterError
  case typesNotComparable
  case booleanRelationOpError
  case invalidBooleanType
  case invalidEdmTypeName
  case unsupportedMethodCall
  case unknownMethodCall
  case invalidParameterType
  case invalidParameterCount
  case castToBoolean
  case invalidMemberExpressionEnd
  case invalidNavPropMultiplicity
  case invalidCastEdmType
  case invalidPathSegmentAfterC_type
  case invalidPathSegmentAfterE_type
  case noMetadataDoc
  case specifiedEntityKeyExists
  case errorCommittingDbTransaction
  case errorGeneratingEntityId
  case invalidLinkAddress
  case errorUpdateEntityNotExist
  case errorUpdateStreamNotExist
  case noServiceDoc
  case fatalInternalError
  case errorUpdateEntityWrongType
  case errorAddingLinkWrongType
  case invalidUseOfInlineCount
  case cannotDeletePrimaryEntity
  case errorGeneratingE_tag
  case errorE_tagsDiffer
  case linkSourceNotExist
  case linkLinkedNotExist
  case modifyLinkViolatesCardinality
  case invalidDownloadSubset
  case definingQueryNotFound
  case invalidDefiningQuery
  case definingQueryNameTooLong
  case invalidEntityExistsParameter
  case shimStoreOptionsNotProvided
  case missingServiceRoot
  case invalidPageSize
  case missingUsername
  case missingPassword
  case missingStoreName
  case missingStorePath
  case shimMissingRequest
  case requestTypeNotSupported
  case missingPayload
  case invalidPayloadType
  case dropDbNotFound
  case couldNotDropDb
  case errorComputingBasicAuth
  case invalidUseOfSkipToken
  case invalidSkipWithSkipToken
  case invalidSkipTokenItemCount
  case invalidSkipTokenItemType
  case invalidCustomHeader
  case shimAllocatePropsEntMissing
  case invalidEntityType
  case multiEntitiesHaveSameKey
  case errorUploadingRequestQueue
  case errorUploadAlreadyInProgress
  case updateEntityDenied
  case errorExecutingRequest
  case methodNotProvided
  case invalidPathForMethod
  case wrongRequestPayload
  case batchQueryOperationExpected
  case emptyBatch
  case emptyChangeSet
  case invalidBatchObject
  case invalidChangeSetObject
  case invalidCustomCookie
  case missingHost
  case invalidPort
  case missingIdentityPassword
  case missingIdentityFile
  case identityOverHttp
  case certificateOverHttp
  case readInChangeSet
  case invalidMaxPageSize
  case cannotUpdateKeyProperty
  case nullifyingNonNullProperty
  case invalidGuidValue
  case storeVersionTooNew
  case noE_setOrE_typeForUrl
  case replaceDbFailed
  case serviceRootNotAbsolute
  case requestModeMissing
  case errorDeleteLinkNotExist
  case invalidEntitySetWithIsLocal
  case androidContextNotProvided
  case shimUnknownRequestObject
  case producerError
  case resourceNotFound
  case iosShimMissingStoreDelegate
  case javaShimMissingStoreDelegate
  case cannotPutLocalEntity
  case dropDbInUse
  case notGlobalInit
  case androidCertStoreError
  case requestFailedSeeResponse
  case deepInsertsNotSupported
  case deepInsertToEntitySet
  case tooManySystemDownloads
  case mediaStreamsNotSupported
  case generatedUrlForStreamRequest
  case invalidStreamUrl
  case nonMediaEntityInStreamRequest
  case noStreamRequest
  case expandInStreamUrl
  case streamingToInvalidUrl
  case noInputStreamInMediaResource
  case noContentTypeInMediaResource
  case errorReadingFromInputStream
  case mediaStreamAlreadyAvailable
  case mediaEntityDoesNotExist
  case requestExists
  case readingStreamInBatch
  case invalidStreamRequestName
  case streamRequestNameTooLong
  case androidStreamListenerMissing
  case wrongMethodForStreamRead
  case wrongMethodForNonStreamRead
  case requestForMediaStreamExists
  case updateBindingToEntitySet
  case invalidEntitySetWithIsError
  case valueExceedsMaxLengthFacet
  case rowExceedsPageSize
  case invalidQueryForArchiveEntity
  case invalidStoreName
  case invalidStorePath
  case invalidStoreEncryptionKey
  case unsupportedStreamInDeepInsert
  case modifyingStreamInBatch
  case serviceRootChanged
  case nonN_sStringCustomHeader
  case notHandleUnknownType
  case errorEncodingJson
  case noE_setForE_type
  case ambiguousE_setForE_type
  case invalidStorePathScp
  case invalidPageSizeScp
  case invalidValue
  case dataTypeNotSupportedScp
  case noReadEditLinkForDownloadStream
  case noEditLinkForUploadStream
  case invalidStreamTypeForUploadStream
  case mandatoryCookiesNotAvailable
  case invalidSystemQueryOption
  case noTargetEntityForDeleteLink
  case unableToDetermineUrl
  case invalidEdmDecimal
  case duplicatedNestedLambdaVariable
  case invalidLambdaNavPath
  case nonBooleanLambdaExpression
  case invalidLambdaVariableUse
  case jsonSyntaxError
  case fixingRequestNotSupported
  case httpHeaderNotSupported
  case readingReqEntityNotSupported
  case invalidComplexType
  case invalidUseOfRemoveAfterUpload
  case removeAfterUploadNotSupported
  case invalidBindOnPrincipalEntity
  case invalidHeaderFormat
  case invalidHeaderFormatNotKey
  case invalidHeaderFormatEntityNotFound
  case invalidHeaderFormatNotEntity
  case invalidHeaderFormatFormat
  case failToUpdateRelationship
  case failToRemoveRelationship
  case getAuthStreamParmsFailure
  case failedToConnectToServer
  case deletingErrorArchiveInBatch
  case errorDeleteEntityNotExist
  case errorDeleteStreamNotExist
  case missingInfoForTransactionMerge
  case invalidDefiningQueryName
  case generatedUrlForDefiningQuery
  case invalidUrlForDefiningQuery
  case noMediaStreamsInUrl
  case urlDoesNotIdentitySingleEntity
  case illegalValue
  case errorCancelNoDownload
  case errorCancelNoUpload
  case errorSystemRefreshInProgress
  case nonContentIdReferenceToNewEntity
  case nonContentIdReferenceToNewEntityLinks
  case nonContentIdReferenceToNewEntityBinds
  case metadataNotLoaded
  case entitySetNotFound
  case propertyNotFoundFullType
  case propertyNotFoundNsType
  case sendStoreFailed
  case upsertedLastDownloadWithErrorArchive
  case sendStoreNotSupported
  case invalidTimeoutValue
  case invalidEdmTypeToX_script
  case invalidDataTypeFromX_script
  case invalidResponseTypeToX_script
  case invalidStoreState
  case invalidRequestType
  case invalidMediaType
  case invalidBatchType
  case invalidEntityOperation
  case invalidLinkOperation
  case authenticationTimeout
  case invalidEntitySetWithPending
  case invalidUseOfHasLocalRelatives
  case invalidUseOfHasRelativesWithPendingChanges
  case invalidStringTransactionId
  case noTransactionIdAssociated
  case transactionIdFromNewEntity
  case invalidRequestForGenerateTransactionId
  case couldNotDetermineEntityIdForTransactionId
  case errorErrorArchiveDeleteWhileUploadInProgress
  case syncFileOperationInterrupted
  case syncFileFailedServerError
  case syncFileFailedBadStatusRetry
  case syncFileFailedBadStatus
  case syncFileFailedAuthRequired
  case syncFileFailedInvalidCharacter
  case syncFileFailedHostNotFound
  case syncFileFailedSocketConnect
  case syncFileCommunicationError
  case syncFileDefault
  case syncFileMaxRetry
  case createReadonlyEntityInstance
  case queryOnWrongEntitySet
  case cannotAccessEntitySetDirectly
  case missingEntityId
  case noEntityFoundWithId
  case errorNothingCanBeUndone
  case clientUpgradeNeededForUndo
  case jsonInvalidUnicodeSequence
  case invalidValueDecimalScaleToZero
  case concurrentMediaStreamModificationsNotSupported
  case concurrentChangeSetWithMediaStreamNotSupported
  case errorGeneratingTempTable
  case invalidStringUploadCategory
  case generateIdNotAllowedWhenUpload
  case invalidRequestForGenerateUploadCategory
  case uploadCategoryFromNewEntity
  case noUploadCategoryAssociated
  case serverLostDownload
  case noFunctionImportForUrl
  case functionImportsNotSupported
  case getFunctionImportNotSupported
  case invalidEntitySetOrFunctionImport
  case invalidFunctionImportVerb
  case invalidUploadCategory
  case invalidRequestForGenerateUploadCategoryL_oData
  case noUploadCategoryAssociatedL_oData
  case generateIdNotAllowedWhenUploadL_oData
  case syncFileFailedDownloadConflict
  case subsetDownloadAlreadyInProgress
  case illegalLiteralValue
  case conversionError
  case invalidParameterTypeTimeOfDay
  case invalidParameterTypeDate
  case invalidDurationOperation
  case invalidPathSegmentAfterRef
  case invalidKeyPredBeforeRef
  case missingIdForDollarEntity
  case invalidIdQueryOption
  case missingIdForDeleteRef
  case invalidUseOfDollarId
  case idResourcePathMismatch
  case duplicateContentId
  case errorGeneratingContentId
  case invalidPathSegmentFollowingStar
  case unsupportedO_dataVersion
  case syncFileFailedDeployFileNotFound
  case errorCancelNoOperation
  case changeSendStoreEncryptionKeyFailed
  case sendStoreWithNewEncryptionKeyFailed
  case sendStoreCopyStoreFailed
  case sendStoreCopyRequestQueueFailed
  case sendStoreRenameFailed
  case sendStoreGetSizeFailed
  case cannotOrderByStreamProperty
  case streamPropertyInFilter
  case invalidPathSegmentAfterStream
  case streamPropertyPathTooLong
  case noEditLinkForDeleteStream
  case schemaUpgradeNotAllowed
  case requestNotExists
  case requestBeingRemoved
  case removeDefiningQueryNotEnabled
  case removeDefiningQueryWithPartialDownload
  case removeDefiningQueryWithPendingChanges
  case disqualifiedEnumName
  case invalidEnumValue
  case invalidEnumType
  case diffEnumTypeForHas
  case arrayIsNil
  case noEnoughLengthForArray
  case invalidN_sString
  case reBootstrapNotAllowed
  case currentUserWasNotProvided
  case hasErrorWhenUploadPreviousUserChanges
  case hasPendingRequestsWhenUserSwitch
  case sendStoreNoteTooLong
  case functionsNotSupported
  case actionsNotSupported
  case collectionParametersNotSupported
  case noFunctionForUrl
  case noActionForUrl
  case boundDataMethodsNotSupported
  case invalidParameterValue
  case unrecognizedParameter
  case invalidHttpMethodForActionV4
  case nullifyingNonNullParameter
  case unrecognizedDataType
  case invalidMethodName
  case bindingParameterMismatch
  case missingNonNullableParameters
  case bindingParameterTypeNotSupported
  case bindToNonExistEntity
  case unsupportedSelectCollectionPropertyItem
  case invalidPathSegmentAfterCollectionProperty
  case orderByCollectionPropertyItemNotSupport
  case orderByCollectionPropertyItemCountNotSupport
  case orderEntityByCollectionProperty
  case filterByCollectionPropertyItemNotSupport
  case filterByCollectionPropertyItemCountNotSupport
  case unsupportedCollectionTypeQuery
  case invalidItemIndexOfCollection
  case noSuchItemIndexOfCollection
  case typesNotComparableInMemory
  case operationNotSupportedInMemory
  case unsupportedCastInMemory
  case failToGenerateDefaultEncryptionKey
  case upsertedLastDownloadWithRequestQueue
  case invalidQueryForRequestQueue
  case deletingRequestInBatch
  case unsupportedUndoOption
  case errorDeleteRequestWhileUploadInProgress
  case connectionWasInterrupted
  case generalInternalError
  case conflictMbtClientInstanceId
  case errorFetchingClientInstanceId
  case errorDeletingClientInstanceId
  case duplicatedKeyPropertiesInDeepInsert
  case geospatialPropertyInFilter
  case cannotOrderByGeospatialProperty
  case errorUpgradeClientOnlySchema
  case errorPurgeClientOnlyData
  case errorPreviousMetadataNotFound
  case errorEmptyMetadata
  case errorIncompatibleMetadata
  case errorMetadataVersionMismatch
  case errorMetadataClientOnlyEntityNotFound
  case errorGeneratingClientSchema
  case errorClientOnlyRequestsExist
  case navigationKeyDifferentWithDirectRelateEntity
  case cannotUpdateLinkThroughNavigationKey
  case cannotUpdateDependentPropertyForNavigationKey
  case cannotReplaceBindingWithoutDependantProperty
  case cannotDirectPostEntityWithNavigationKey
  case partKeyWereReferInNavigationKey
  case keyAliasNameIsNotUnique
  case navigationKeyCouldNotBeNullable
  case canNotLocatePropertyWithNamePath
  case keyPropertyRefToNullableNavigationProperty
  case namePathLocatedIsNotA_simpleProperty
  case navigationKeyPathIsDuplicated
  case keyPropertyRefToNullableComplexProperty
  case keyPropertyRefToNullablePropertyItem
  case keyReferenceNotEnabled
  case navigationKeyDifferentWithDependantProperty
  case failToRemoveRelationshipForNavigationKey
  public init(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension SAPOfflineOData.OfflineODataOperationStep : Swift.Equatable {}
extension SAPOfflineOData.OfflineODataOperationStep : Swift.Hashable {}
extension SAPOfflineOData.OfflineODataOperationStep : Swift.RawRepresentable {}
extension SAPOfflineOData.TransactionIDType : Swift.Equatable {}
extension SAPOfflineOData.TransactionIDType : Swift.Hashable {}
extension SAPOfflineOData.UploadCategoryType : Swift.Equatable {}
extension SAPOfflineOData.UploadCategoryType : Swift.Hashable {}
extension SAPOfflineOData.OfflineODataClientLogLevelInternal : Swift.Equatable {}
extension SAPOfflineOData.OfflineODataClientLogLevelInternal : Swift.Hashable {}
extension SAPOfflineOData.OfflineODataClientLogLevelInternal : Swift.RawRepresentable {}
extension SAPOfflineOData.OfflineODataErrorName : Swift.Equatable {}
extension SAPOfflineOData.OfflineODataErrorName : Swift.Hashable {}
